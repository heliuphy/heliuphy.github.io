<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="阮一峰JS学习笔记"><meta name="keywords" content="javascript"><meta name="author" content="He Liu,undefined"><meta name="copyright" content="He Liu"><title>阮一峰JS学习笔记 | HeLiu的博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.2"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script><script src="https://unpkg.com/blueimp-md5@latest/js/md5.min.js"></script><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: {"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"},"path":"search.xml"}
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#阮一峰JS学习笔记"><span class="toc-number">1.</span> <span class="toc-text">阮一峰JS学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是JS"><span class="toc-number">1.1.</span> <span class="toc-text">什么是JS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS都包括什么"><span class="toc-number">1.2.</span> <span class="toc-text">JS都包括什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS难在哪"><span class="toc-number">1.3.</span> <span class="toc-text">JS难在哪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS基础"><span class="toc-number">1.4.</span> <span class="toc-text">JS基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语句and表达式"><span class="toc-number">1.4.1.</span> <span class="toc-text">语句and表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语句"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表达式"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-number">1.4.2.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#变量提升"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">变量提升</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标识符"><span class="toc-number">1.4.3.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区块"><span class="toc-number">1.4.4.</span> <span class="toc-text">区块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制结构"><span class="toc-number">1.4.5.</span> <span class="toc-text">控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#switch结构"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">switch结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标签"><span class="toc-number">1.4.6.</span> <span class="toc-text">标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-number">1.5.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">1.5.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof-运算符"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">typeof 运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-undefined-布尔"><span class="toc-number">1.5.2.</span> <span class="toc-text">null, undefined, 布尔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值"><span class="toc-number">1.5.3.</span> <span class="toc-text">数值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#与数值相关的全局方法"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">与数值相关的全局方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#parseInt"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">parseInt()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#parseFloat"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">parseFloat()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#isNaN"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">isNaN()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#isFinite"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text">isFinite()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.5.4.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-number">1.5.5.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#键名"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">键名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的引用"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">对象的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#with-语句"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">with 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-number">1.5.6.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的声明"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">函数的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一等公民"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">第一等公民</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数名得提升"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">函数名得提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的属性"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">函数的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#作用域"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数"><span class="toc-number">1.5.6.6.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arguments对象"><span class="toc-number">1.5.6.7.</span> <span class="toc-text">arguments对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的其他知识点"><span class="toc-number">1.5.6.8.</span> <span class="toc-text">函数的其他知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eval命令"><span class="toc-number">1.5.6.9.</span> <span class="toc-text">eval命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">1.5.7.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引言"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#基础"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空位"><span class="toc-number">1.5.7.3.</span> <span class="toc-text">空位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类似数组的对象"><span class="toc-number">1.5.7.4.</span> <span class="toc-text">类似数组的对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型转换"><span class="toc-number">1.5.8.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理机制"><span class="toc-number">1.5.9.</span> <span class="toc-text">错误处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Error构造函数"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">Error构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw语句"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">throw语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try…catch结构"><span class="toc-number">1.5.9.3.</span> <span class="toc-text">try…catch结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally代码块"><span class="toc-number">1.5.9.4.</span> <span class="toc-text">finally代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标准库"><span class="toc-number">1.6.</span> <span class="toc-text">标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object对象"><span class="toc-number">1.6.1.</span> <span class="toc-text">Object对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原生方法"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">原生方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将Object-看为一个普通函数（工具函数）"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">将Object()看为一个普通函数（工具函数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当Object-是构造函数时"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">当Object()是构造函数时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object静态方法（即将Object看成一个普通的对象）"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">Object静态方法（即将Object看成一个普通的对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#遍历对象的属性"><span class="toc-number">1.6.1.4.1.</span> <span class="toc-text">遍历对象的属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他方法"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">其他方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object的实例方法"><span class="toc-number">1.6.1.6.</span> <span class="toc-text">Object的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-prototype-valueOf"><span class="toc-number">1.6.1.6.1.</span> <span class="toc-text">Object.prototype.valueOf()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Obbject-prototype-toString"><span class="toc-number">1.6.1.6.2.</span> <span class="toc-text">Obbject.prototype.toString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-prototype-toLocalString"><span class="toc-number">1.6.1.6.3.</span> <span class="toc-text">Object.prototype.toLocalString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-prototype-hasOwnProperty"><span class="toc-number">1.6.1.6.4.</span> <span class="toc-text">Object.prototype.hasOwnProperty()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性描述对象"><span class="toc-number">1.6.2.</span> <span class="toc-text">属性描述对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-getOwnPropertyDescription"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">Object.getOwnPropertyDescription()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他方法-1"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">其他方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元属性"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">元属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的拷贝"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">对象的拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#控制对象状态"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">控制对象状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array对象"><span class="toc-number">1.6.3.</span> <span class="toc-text">Array对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Array-isArray"><span class="toc-number">1.6.3.1.1.</span> <span class="toc-text">Array.isArray()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例方法"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包装对象"><span class="toc-number">1.6.4.</span> <span class="toc-text">包装对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象程序设计"><span class="toc-number">1.7.</span> <span class="toc-text">面向对象程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象是什么"><span class="toc-number">1.7.1.</span> <span class="toc-text">对象是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">1.7.2.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new命令执行过程"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">new命令执行过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化对象的另一个方法Object-create"><span class="toc-number">1.7.3.</span> <span class="toc-text">实例化对象的另一个方法Object.create()</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/avatar.jpg"></div><div class="author-info__name text-center">He Liu</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/images/beautiful-cold-fog-547115%202.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HeLiu的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/slides">slides</a></span></div><div id="post-info"><div id="post-title">阮一峰JS学习笔记</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-10-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/web/">web</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4,756</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><h1 id="阮一峰JS学习笔记"><a href="#阮一峰JS学习笔记" class="headerlink" title="阮一峰JS学习笔记"></a>阮一峰JS学习笔记</h1><h2 id="什么是JS"><a href="#什么是JS" class="headerlink" title="什么是JS"></a>什么是JS</h2><p>它是脚本语言，即不具备开发操作系统的能力，而是只用来编写<strong>控制</strong>其他大型应用程序的”脚本“（比如浏览器）。它是嵌入式语言，即没有IO，只能嵌入更大型得应用程序中，去调用宿主环境的IO。（浏览器、node）</p>
<h2 id="JS都包括什么"><a href="#JS都包括什么" class="headerlink" title="JS都包括什么"></a>JS都包括什么</h2><p>其核心语法相当精简，只包括两部分：</p>
<ul>
<li>基本的语法构造<ul>
<li>操作符</li>
<li>控制结构</li>
<li>语句</li>
</ul>
</li>
<li>标准库</li>
</ul>
<p>除此之外，因为它要有宿主环境，所以就是一系列宿主环境的API。</p>
<h2 id="JS难在哪"><a href="#JS难在哪" class="headerlink" title="JS难在哪"></a>JS难在哪</h2><ul>
<li>它涉及大量的外部API</li>
<li>JS有不少设计缺陷，某些地方相当不合理。</li>
</ul>
<h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="语句and表达式"><a href="#语句and表达式" class="headerlink" title="语句and表达式"></a>语句and表达式</h3><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>指为了<strong>得到返回值的</strong>计算式。</p>
<p>两者的区别在于，语句一般是为了进行某种操作，改编程序运行状态，一般不需要返回值；而表达式是为了得到返回值，其一定会返回一个值。凡是JS中<strong>预期为一个值的</strong>地方，都可以放置表达式。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是对值旳<strong>具名引用</strong>。</p>
<h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JS引擎的工作方式是：<strong>先</strong>解析代码，<strong>获取所有的被声明的变量</strong>，然后再一行一行的运行。这样也就是，所有变量声明的语句，都会被提升到代码头部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>真正运行的是如下代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>也就是用来识别各种值的合法名称。最常见的标识符就是<strong>变量名</strong>，以及<strong>函数名</strong>。</p>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>对于<code>var</code>命令来说，<code>{ }</code>构成的区块不构成单独的作用域。</p>
<h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h4><p>多个<code>if--else</code>结构连在一起的时候，可使用更简单的<code>switch</code>结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"banana"</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"apple"</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>JS语言允许语句的前面有标签。相当于定位符。<br>通常与<code>break</code>和<code>continue</code>配合使用，跳出特定循环。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...)&#123;</span><br><span class="line">            <span class="keyword">if</span>(...)&#123;</span><br><span class="line">                <span class="keyword">break</span> top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以直接跳出外层循环，如果加标签，只默认跳出当前循环。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>数值：整数和小数</li>
<li>字符串</li>
<li>布尔值</li>
<li>undefined 未定义</li>
<li>null 空值</li>
<li>对象</li>
</ul>
<p>注：前三个成为”原始类型的值”，也就是不能再细分了。对象则是“合成类型”的值。至于那两个英文的，就是特殊值。</p>
<p>而至于<strong>对象</strong>，又可以分为三类：</p>
<ul>
<li>狭义的对象 object</li>
<li>数组 array</li>
<li>函数 function</li>
</ul>
<h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><p>这是<strong>运算符</strong>！</p>
<p>预告一下，JS共有三种方式可以确定一个值是什么类型的：</p>
<ul>
<li>typeof 运算符</li>
<li>instanceof 运算符</li>
<li>Object.prototype.toString 方法</li>
</ul>
<h3 id="null-undefined-布尔"><a href="#null-undefined-布尔" class="headerlink" title="null, undefined, 布尔"></a>null, undefined, 布尔</h3><p>null表示值为空值，比如一个参数表示抛出的错误参数，如果此处无错，就会抛出<code>null</code>。</p>
<p>undefined表示未定义</p>
<p>关于布尔值，注意类型转换，空字符串转换为<code>false</code>而空数组和空对象则都是<code>true</code>。</p>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>注意，JS里的所有数字都是64位浮动点数存储。所以</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h4><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串转为整数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h5><p>将字符串转换为浮点数。</p>
<h5 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h5><p>判断一个值是不是<code>NaN</code>。</p>
<h5 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h5><p>判断一个数值是不是一个正常的数值。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以像数组一样访问，但是不可以修改单个字符，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">//这样是改变不了的</span></span><br></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h4><ul>
<li>对象的所有键名都是字符串，所以是否加引号都可以。如果键名是数值，也会被自动转换成字符串。但是如果键名不符合明明规范，则必须加上引号，否则会报错。</li>
<li>键名又称为属性。它的值可以是任意类型，如果是函数，则这个属性又称为方法。</li>
<li>值如果是对象，则形成了链式引用。</li>
</ul>
<h4 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h4><p>如果不同变量名指向同一个变量，那么他们都是这个对象的引用，也就是指向相同的内存地址。改一个，其他的都会变。</p>
<p><strong>注意：</strong>这种引用仅限于对象，如果是<strong>原始类型的值</strong>的话，那么变量就是值的<strong>拷贝</strong>。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>有两种运算符，一个是点运算符，另一个就是方括号运算符。</li>
<li>需要查看一个对象的所有属性，可以使用`Object.keys(yourObj)’方法。</li>
<li><p>属性的删除，使用<code>delete</code>命令。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.p</span><br></pre></td></tr></table></figure>
</li>
<li><p>要查看属性是否存在，可使用<code>in</code>运算符。即使是继承的属性，也会返回<code>true</code>。如果不需要继承，看下一条</p>
</li>
<li>判断自身属性，可使用<code>hasOwnProperty()</code>方法来判断。</li>
<li><p>怎么遍历对象的全部属性，可以使用<code>for...in...</code>循环。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> onj) &#123;</span><br><span class="line">    f(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  注意，会遍历继承的属性。但是必须是<strong>可遍历的对象</strong>。</p>
<p>  如果想遍历自身的属性，那么可以结合<code>hasOwnProperty()</code>方法判断一下。</p>
<h4 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(对象)&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样提供的一种便利就是，在操作一个对象的多个属性时，会方便许多。</p>
<p>注意，<code>with</code>区块不会改变作用域，所以如果要给一个新属性赋值，需要先有这个属性才行。</p>
<p><strong>建议：</strong>不要使用<code>with</code>，可以使用一个临时变量来代替这种功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(obj1.obj2.obj3) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3;</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>三种方法</p>
<ol>
<li>function命令—函数的声明</li>
<li>函数表达式—变量赋值的写法，将匿名函数赋值给一个变量，这个匿名函数又叫<strong>函数表达式</strong>。</li>
<li>Function构造函数—几乎无人使用，不管了</li>
</ol>
<h4 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h4><p>函数在js中只是一种可以执行的值而已，与其他值无特殊之处。凡是可以使用值得地方，都可以使用函数。</p>
<h4 id="函数名得提升"><a href="#函数名得提升" class="headerlink" title="函数名得提升"></a>函数名得提升</h4><p>因为函数名就是变量名，所以使用<code>function</code>命里声明函数的时候，整个函数就会像变量声明一样，被提升到顶部。</p>
<h4 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h4><ul>
<li><p>name属性<br>  主要作用：获取作为参数得函数的名字。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) <span class="comment">//得到myFunc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>length属性<br>  返回函数预期传入的<strong>参数的个数</strong>，即函数定义中的参数个数。<br>  其作用可实现方法的<strong>重载</strong>。</p>
</li>
<li>toString()<br>  返回一个字符串，内容是函数的源码。<br>  其作用可以实现多行字符串。</li>
</ul>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在js中只有两种作用域，一个是<strong>全局作用域</strong>，另一个就是<strong>函数作用域</strong>。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p>关于函数值得传递方式</p>
<ul>
<li>函数参数如果是原始类型得值，那么就<strong>按值传递</strong>。也就是说在函数体内修改参数值，不会影响到函数外部。    </li>
<li>如果函数参数是复合类型-（数组、对象、函数）的值，那么传递方式就是传址传递。</li>
<li><p>这里有一个小点需要注意一下就是，如果在函数体内部修改了整个参数的值，而不是某个属性。那么原对象的值是不会被修改的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1.</span> <span class="number">2.</span> <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>这里，直接让参数o指向了另外一个对象，保存在原地址上的值当然不会受影响。</p>
<h4 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h4><p>只在函数体内部可以使用，这个对象包含了函数运行时的所有参数。<code>arguments[0]</code>是第一个参数。<br>    <code>arguments</code>对象含有一个<code>callee</code>属性返回它所对应的函数。</p>
<h4 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h4><ul>
<li>闭包：也就是能够读取其他函数内部变量的函数。<ul>
<li>小引例：因为js内层的函数可以读取外层函数的变量，而外层函数却能读取内部函数的变量，所以要想实现读取某个内部函数的变量可以通过下面这个函数实现<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">//99</span></span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
</li>
</ul>
<p>这样就可以拐弯抹角的实现这个功能了。</p>
<ul>
<li>闭包在这里就是这个函数<code>f2</code> , 他也就是将内部变量和外部变量相互链接的桥梁。</li>
<li>闭包有两个作用<ul>
<li>一个是可以让外部函数访问内部函数的变量</li>
<li>第二就是可以让运行环境保存住函数内部的变量</li>
</ul>
</li>
<li>闭包还可以封装对象的私有属性和私有方法</li>
<li>闭包会保留外层函数的内部变量，造成内存消耗，不能滥用。</li>
<li>立即调用的函数表达式<br>这里有一个很有意思的点，就是<code>function(){}</code>既可以当语句又可以当表达式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所以为了能够区分，js引擎就认为<code>function</code>出现在行首就是一个语句。<br>但是加个括号阔起来就可以让引擎认为是一个表达式了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;...&#125;)();<span class="comment">//这样就可以直接调用函数了。</span></span><br></pre></td></tr></table></figure></p>
<p>为了避免污染全局变量，经常会直接调用匿名函数。</p>
<h4 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h4><p>eval接受一个字符串作为参数，并将这个字符串当做语句执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = q'</span>);</span><br><span class="line">a <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<p>会影响当前作用域的变量，不推荐使用。一般用来解析JSON但是JSON最好还是用<code>JSON.parse</code>方法。<br><strong>注意：</strong>只有<code>eval()</code>这一种形式属于直接调用，剩下的全属于别名调用，别名调用的<code>eval()</code>通通影响的事<strong>全局</strong>作用域。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tyoeof [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure>
<p>可见数组的类型就是对象，那么数组有什么不同呢，数组的特殊性就体现在它的键名是按次序排列的一组整数<code>(0,1,2...)</code>。</p>
<p>但是读取的时候，对于数组的键名，不能使用点号读取。（因为数字开头不是合法的标识符）。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>length属性</li>
<li>in 运算符</li>
<li>for … in … 循环和数组遍历<ul>
<li>注意，这个不仅会遍历数组的数字键，还会遍历非数字键。</li>
<li>所以不推荐使用</li>
</ul>
</li>
<li>那么想简历数组最好使用<code>for</code>OR<code>while</code>循环。</li>
<li>数组的<code>forEach()</code>方法也能<strong>遍历数组</strong>。<h4 id="空位"><a href="#空位" class="headerlink" title="空位"></a>空位</h4>空位不同于<code>undefined</code>，遍历数组是，空位不会被遍历。<h4 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h4>只要有<code>length</code>属性，就可以认为是类似数组对象，但是它不是数组。要想将其转换为数组可以使用数组的<code>slice()</code>方法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>
<p>使用<code>call()</code>方法可以对类似数组的对象使用数组的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>
<p>这样就可以让<code>arrayLike</code>使用<code>forEach</code>方法。</p>
<p>实际使用中最好还是先转成数组再使用。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>注意强制类型转换Number()和parseInt的区别<ul>
<li>Number()函数比parseInt()函数要严格很多。基本上，只要有一个字符无法转成述职，整个字符串就是<code>NaN</code>。而，<code>parseInt()</code>却可以将前几个是数字的字符提取出来。</li>
</ul>
</li>
<li>自动转换的规则<ul>
<li>预期是什么类型的值，就调用该类型得转换函数。<h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><h4 id="Error构造函数"><a href="#Error构造函数" class="headerlink" title="Error构造函数"></a>Error构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错信息'</span>);</span><br><span class="line">err.message <span class="comment">// "出错信息"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>此外还有几个派生的错误类</p>
<ul>
<li>SyntaxError</li>
<li>ReferenceError</li>
<li>RangeError</li>
<li>TypeError</li>
<li>URIError</li>
<li>EvalError</li>
<li>自定义错误类型（继承自Error）</li>
</ul>
<h4 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h4><p>作用是手动<strong>中断程序</strong>执行，抛出一个错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'x必须为正数'</span>); <span class="comment">//这里抛出一个错误对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="try…catch结构"><a href="#try…catch结构" class="headerlink" title="try…catch结构"></a>try…catch结构</h4><p>发生错误后可以对错误进行处理，捕捉错误，并决定是否执行下去。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error occured'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123; <span class="comment">// 这里的参数e就是捕获上面那个try返回的错误对象（这里为了产生错误，强行用了throw语句）</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">    <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p><code>try...catch</code>后面还可以跟一个<code>finally</code>代码块，<strong>无论是否出现错误</strong>，都会执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanUp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error occured'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'此行不会执行'</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'完成清理工作'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleanUp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Error: error occured</span></span><br></pre></td></tr></table></figure></p>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><p>JS其他所有对象都是<strong>继承</strong>自<code>Object</code>对象，即都是<code>Object</code>的<strong>实例</strong>。</p>
<h4 id="原生方法"><a href="#原生方法" class="headerlink" title="原生方法"></a>原生方法</h4><ul>
<li><p>一类是<code>Object</code>本身的方法，</p>
<ul>
<li>即直接定义在Object对象上</li>
<li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; <span class="built_in">console</span>.log(o)&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>还有一类就是<code>Object</code>的实例方法。</p>
<ul>
<li>即定义在Object原型对象<code>Object.prototype</code>上的方法。可以被Object实例直接使用。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.print()</span><br></pre></td></tr></table></figure>
<ul>
<li>obj会直接继承 <code>Object.prototype</code> 上的方法.</li>
</ul>
<h4 id="将Object-看为一个普通函数（工具函数）"><a href="#将Object-看为一个普通函数（工具函数）" class="headerlink" title="将Object()看为一个普通函数（工具函数）"></a>将Object()看为一个普通函数（工具函数）</h4><p>功能1：将任意值转换为对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>功能2：判断某个变量是不是对象。因为Object有一个特点，就是当他的参数本身就是个对象的话，那么返回的还是原变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(arr); <span class="comment">// 返回原数组</span></span><br><span class="line">obj === arr <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="当Object-是构造函数时"><a href="#当Object-是构造函数时" class="headerlink" title="当Object()是构造函数时"></a>当Object()是构造函数时</h4><p>即前面可以使用<code>new</code>命令。使用方法几乎等同于工具函数Object()，但是语义不一样。工具函数是指<strong>转换</strong>成对象。</p>
<h4 id="Object静态方法（即将Object看成一个普通的对象）"><a href="#Object静态方法（即将Object看成一个普通的对象）" class="headerlink" title="Object静态方法（即将Object看成一个普通的对象）"></a>Object静态方法（即将Object看成一个普通的对象）</h4><p>即部署在Object对象自身的方法。</p>
<h5 id="遍历对象的属性"><a href="#遍历对象的属性" class="headerlink" title="遍历对象的属性"></a>遍历对象的属性</h5><ul>
<li>Object.keys()</li>
<li>Object.getOwnPropertyNames()</li>
</ul>
<p>这两个的参数都是一个对象。区别在于，keys只返回可枚举的属性，而getOwnPropertyNames方法还可以返回补课枚举的属性。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li>对象属性模型的相关方法</li>
<li>控制对象状态的方法</li>
<li>原型链相关方法</li>
</ul>
<h4 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h4><p>也就是定义在Object.prototype对象上的方法。所有Object的实例对象都继承了这些方法。</p>
<h5 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h5><p>返回一个对象的值，默认返回对象本身。其主要作用在于，自动类型转换时会<strong>调用</strong>。</p>
<h5 id="Obbject-prototype-toString"><a href="#Obbject-prototype-toString" class="headerlink" title="Obbject.prototype.toString()"></a>Obbject.prototype.toString()</h5><p>返回一个对象的字符串形式。默认返回<strong>类型</strong>字符串。也用于自动类型转换。可以得到想要的字符串形式。<br><strong>注意，</strong>这些函数有可能被用户重写，如果依然想调用，最好使用<code>Object.prototype.toString.call()</code>方法。<br>可以用于判断类型以及构造函数。这样会比<code>typeof</code>运算符更精确。</p>
<h5 id="Object-prototype-toLocalString"><a href="#Object-prototype-toLocalString" class="headerlink" title="Object.prototype.toLocalString()"></a>Object.prototype.toLocalString()</h5><p>与<code>toString</code>基本相同，也是返回字符串，但是可以加上一些用户的信息。比如返回日期的实例类型对象时，就和地域相关。</p>
<h5 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h5><p>返回一个布尔值，表示该实例对象自身是否具有该属性。</p>
<h3 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h3><p>是一种数据结构，用来描述某个属性是否可写、可遍历等。每个属性都有自己的属性描述对象。</p>
<h4 id="Object-getOwnPropertyDescription"><a href="#Object-getOwnPropertyDescription" class="headerlink" title="Object.getOwnPropertyDescription()"></a>Object.getOwnPropertyDescription()</h4><p>获取属性描述对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescription()</span><br></pre></td></tr></table></figure>
<h4 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li>Object.getOwnPropertyNames()</li>
<li>Object.defineProkperty()</li>
<li>Object.defineProperties()</li>
<li>Object.prototype.propertyIsEnumerable()</li>
</ul>
<h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p>也就是属性描述对象的属性</p>
<ul>
<li>value</li>
<li>writable</li>
<li>enumerable — 可以用来设置私密属性，只是不可以遍历到，但是还是可以访问的。如果要获取自身的所有属性（不管是否可遍历，都可以使用getOwnPropertyNames）</li>
<li>configurable – 是否可以修改属性描述对象</li>
<li><p>getter/setter – 存取器</p>
<p>  存取器有两种写法，一个是在键<code>get</code>和<code>set</code>的后面直接给出值。另一种是<code>get p() {}</code>和<code>set p(value) {}</code></p>
</li>
</ul>
<h4 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h4><p>这里要注意的是，怎么拷贝过来get()属性等。</p>
<h4 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h4><ul>
<li>Object.preventExtentions()</li>
<li>Object.isExtensible()</li>
<li>Object.seal()</li>
<li>Object.isSealed()</li>
<li>Object.freeze()</li>
<li>Object.isFrozen()</li>
</ul>
<h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><p><code>Array</code>是JS的原生<strong>对象</strong>，同时也是<strong>构造函数</strong>。</p>
<p>因为当Array构造函数的参数不同时，他的行为很不一致，所以最好直接使用数组字面量来创建新数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad </span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//good </span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><h5 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h5><p>可以弥补<code>typeof</code>运算符的不足。</p>
<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul>
<li>valueOf()</li>
<li>toString()</li>
<li>push(), pop()</li>
<li>shift(), unshift()</li>
<li>join()—连接数组成员为字符串（可以自定义分隔符）</li>
<li>concat() —— 用于多个数组的合并</li>
<li>reverse()</li>
<li>slice() - arr.slice(start, end) –提取</li>
<li>splice() - arr.splice(start, end, addElem1, addElem2 ,….)删除，并且可以在删除的位置添加。返回值是被删除的元素。</li>
<li>sort()</li>
<li>map()</li>
<li>forEach()</li>
<li>filter()</li>
<li>some(), every()</li>
<li>reduce(), reduceRight()</li>
<li>indexOf(), lastIndexOf</li>
</ul>
<h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>就是将三种原始数据类型的值（数值、字符串、布尔值）包装为对象。</p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>可以从两个方面来理解：</p>
<ul>
<li>对象时<strong>单个实物</strong>的抽象。</li>
<li>对象是一个<strong>容器</strong>，封装了属性和方法。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>JS与C++不同，没有类的概念，也就是他不是基于类的，而是基于<strong>构造函数（constructor）</strong>和<strong>原型链（prototype）</strong>。JS使用构造函数作为对象的<strong>模板</strong>。一个构造函数，可以生成多个实例对象。</p>
<p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>new命令：因为new命令本身就可以执行函数，不再需要函数的调用，所以可以不加括号执行，但是还是推荐加括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle;</span><br></pre></td></tr></table></figure>
<p>如果不使用<code>new</code>命令，而直接调用构造函数，会发生：构造函数变为普通函数，不会再生成实例对象，这里的<code>this</code>也将会代表全局对象。</p>
<h4 id="new命令执行过程"><a href="#new命令执行过程" class="headerlink" title="new命令执行过程"></a>new命令执行过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">constructor, plarams</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将arguments对象转为数组</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//取出构造函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = args.shift();</span><br><span class="line">    //创建一个空对象，继承构造函数的prototype属性</span><br><span class="line">    var context = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">    //执行构造函数</span><br><span class="line">    var result = <span class="keyword">constructor</span>.apply(context, args);</span><br><span class="line">    //如果返回结果是对象，就直接返回，否则返回context对象。</span><br><span class="line">    return (typeof result === 'object' &amp;&amp; result != null) ? result:context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例</span><br><span class="line">var actor = _new(Person, '张三', 28);</span><br></pre></td></tr></table></figure>
<h3 id="实例化对象的另一个方法Object-create"><a href="#实例化对象的另一个方法Object-create" class="headerlink" title="实例化对象的另一个方法Object.create()"></a>实例化对象的另一个方法Object.create()</h3><p>在拿不到构造函数，而只能拿到一个现有的对象的时候，我们可以以这个对象为模板，来生成新的实例对象。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">He Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://heliu.io/2018/10/14/阮一峰JS学习笔记/">https://heliu.io/2018/10/14/阮一峰JS学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://heliu.io" target="_blank">HeLiu的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/javascript/">javascript</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/qrcode/alipay.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/qrcode/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share" data-disabled="facebook"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script><nav id="pagination"><div class="next-post pull-right"><a href="/2018/07/28/自己构建Docker镜像在自己的服务器上搭建支持C++和tensorflow的jupyter-notebook/"><span>自己构建Docker镜像在自己的服务器上搭建支持C++和tensorflow的jupyter-notebook</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'ad7cd539b86faeab9c35',
  clientSecret: '4e6c00fca2d4e6e2c7c725936748e69ecb3a277c',
  repo: 'Gitalk',
  owner: 'heliuphy',
  admin: 'heliuphy',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2018 By He Liu</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.2"></script><script src="/js/fancybox.js?version=1.5.2"></script><script src="/js/sidebar.js?version=1.5.2"></script><script src="/js/copy.js?version=1.5.2"></script><script src="/js/fireworks.js?version=1.5.2"></script><script src="/js/transition.js?version=1.5.2"></script><script src="/js/scroll.js?version=1.5.2"></script><script src="/js/head.js?version=1.5.2"></script></body></html>
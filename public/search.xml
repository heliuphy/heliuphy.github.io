<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iPhone怎么在手机上设置自定义铃声</title>
      <link href="/2018/12/24/iPhone%E6%80%8E%E4%B9%88%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%83%E5%A3%B0/"/>
      <url>/2018/12/24/iPhone%E6%80%8E%E4%B9%88%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8A%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%83%E5%A3%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大家都知道iPhone在手机上是很难设置自定义铃声的，只能通过电脑来操作，但是现在有一个新的方法来实现这个功能，而且不需要下载第三方软件，那就是借助iOS自家的“库乐队”APP。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>唯一需要准备的那就是库乐队APP了，检查一下你的手机上有没有这款软件，如果没有的话，就去app store下载一个就好了。</p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>下面开始详细解释操作步骤</p><h3 id="先打开库乐队并点击右上角的-号"><a href="#先打开库乐队并点击右上角的-号" class="headerlink" title="先打开库乐队并点击右上角的+号"></a>先打开库乐队并点击右上角的+号</h3><p><img src="https://i.loli.net/2018/12/24/5c203671e7554.png" alt="第一步新建项目"></p><h3 id="然后选择录音机"><a href="#然后选择录音机" class="headerlink" title="然后选择录音机"></a>然后选择录音机</h3><p><img src="https://i.loli.net/2018/12/24/5c2036779f088.png" alt="第二步选择录音机"></p><h3 id="选择纯音"><a href="#选择纯音" class="headerlink" title="选择纯音"></a>选择纯音</h3><p>第三步选择纯音，当然，如果你想有特殊的音效也可以。<br><img src="https://i.loli.net/2018/12/24/5c20367f5c0e4.png" alt="第三步"></p><h3 id="导入本地歌曲"><a href="#导入本地歌曲" class="headerlink" title="导入本地歌曲"></a>导入本地歌曲</h3><p>点击右上角那里的按键（从右边数第二个，就像一个圆圈的那个键）<br><img src="https://i.loli.net/2018/12/24/5c203682e561b.png" alt="第四步"></p><h3 id="选择歌曲文件"><a href="#选择歌曲文件" class="headerlink" title="选择歌曲文件"></a>选择歌曲文件</h3><p>在上面的选项卡里选择“文件”<br>，然后就可以进到你的文件管理器中选择歌曲啦～</p><p><img src="https://i.loli.net/2018/12/24/5c20368697bc1.png" alt="第五步"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iPhone </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu18.04完美配置优化美化</title>
      <link href="/2018/12/22/Ubuntu18.04%E5%AE%8C%E7%BE%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/12/22/Ubuntu18.04%E5%AE%8C%E7%BE%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>这里先展示一下美化完成Ubuntu18.04之后的效果。<br><img src="https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/images/2018-12-22%2017-05-04%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="Chrome浏览器"></p><p><img src="https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/images/2018-12-22%2017-06-32%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="桌面"></p><p><img src="https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/images/2018-12-22%2017-06-45%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="文档管理器"></p><p><img src="https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/images/2018-12-22%2017-06-56%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="launch"></p><p>是不是很心动呢，那就跟我的步骤一起来做吧。很简单的。</p><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><h3 id="预习部分"><a href="#预习部分" class="headerlink" title="预习部分"></a>预习部分</h3><p>这里需要首先知道的一点小姿势是：在Ubuntu 18.04 LTS中，默认桌面系统不再采用Ubuntu 16.04 LTS的Unity，而是改用Gnome3。由于这里的配置工作，需要用到许多apt源，所以建议读者先把Ubuntu的源改为国内的。这里我改为了清华源。步骤如下：</p><h3 id="更改源"><a href="#更改源" class="headerlink" title="更改源"></a>更改源</h3><h4 id="先备份自己电脑上的源"><a href="#先备份自己电脑上的源" class="headerlink" title="先备份自己电脑上的源"></a>先备份自己电脑上的源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure><h4 id="编辑-etc-apt-sources-list文件"><a href="#编辑-etc-apt-sources-list文件" class="headerlink" title="编辑/etc/apt/sources.list文件"></a>编辑/etc/apt/sources.list文件</h4><p>将<code>/etc/apt/sources.list</code>文件里的内容全部删掉，替换为以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure></p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>打开终端，执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></p><h3 id="正式上课"><a href="#正式上课" class="headerlink" title="正式上课"></a>正式上课</h3><p>下面就来开始正式美化主题啦。</p><p>还记得刚刚预习里提到的内容吗，就是Ubuntu 18.04的桌面系统开始启用gnome3，那么想优化gnome3桌面，需要先下载一个小软件<code>Gnome-tweak-tool</code>，安装也是很简单的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-tweak-tool</span><br></pre></td></tr></table></figure><p>安装完成后，就可以在系统启动台里找到这个工具了。（如果你是中文系统，那么这个工具的名字将为“优化“）。</p><p>打开这个软件后，就可以在第一个标签页里修改主题了。当然，也可以在这个工具里管理你的ubuntu插件（可以理解为chrome浏览器里的插件）。</p><h4 id="下载ubuntu主题"><a href="#下载ubuntu主题" class="headerlink" title="下载ubuntu主题"></a>下载ubuntu主题</h4><p>由于系统内置的主题都不是很惊艳，我们可以从别的地方下载。博主的主题下载地址是：</p><p>桌面主题：<a href="https://github.com/vinceliuice/vimix-gtk-themes" target="_blank" rel="noopener">vinceliuice/vimix-gtk-themes</a></p><p>图标主题：<a href="https://github.com/vinceliuice/vimix-icon-theme" target="_blank" rel="noopener">vinceliuice/vimix-icon-theme</a></p><p>如果不满意这一款主题，这里有更多图标和主题可以到这里下载：<a href="https://www.opendesktop.org/s/Gnome" target="_blank" rel="noopener">Eyecandy for your GNOME-Desktop</a></p><h4 id="更改ubuntu主题"><a href="#更改ubuntu主题" class="headerlink" title="更改ubuntu主题"></a>更改ubuntu主题</h4><p>安装完成后，就可以到“优化”（也就是刚刚安装的那个工具）里更改主题了。这里需要更改主题和图标主题。</p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>当然，只是更改主题还不能拥有上述效果。这里还需要安装一些插件。</p><p>插件的安装方法就是在系统自带的软件中心搜索下载即可。一般在搜索结果的最后。</p><p>需要安装的插件有：</p><ul><li>User theme：<br>使shell主题可以使用桌面主题。(shell即为顶部栏，shell主题和桌面主题不一样，是个单独的模块)</li><li>Dash to panel：<br>类似Windows的任务栏</li><li>Dynamic panel transparency：<br>设置透明效果</li></ul><p>安装完毕后，就可以在“优化”软件里进行设置了。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>如果想继续优化terminal的话，可以安装zsh和oh-my-zsh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装zsh</span></span><br><span class="line">sudo apt-get install zsh </span><br><span class="line"><span class="comment"># 安装oh-my-zsh</span></span><br><span class="line"><span class="comment"># 没有安装git的话先安装git</span></span><br><span class="line">sudo apt-get install git </span><br><span class="line"><span class="comment"># 然后</span></span><br><span class="line">sudo wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完后重启</span></span><br></pre></td></tr></table></figure></p><p>当然了，如果ubuntu的字体看不惯，也可以选择安装微软的字体。这个我会在后续继续出教程，欢迎关注。</p><blockquote><p>参考：<a href="https://zhuanlan.zhihu.com/p/37314255" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37314255</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 系统美化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双系统win10访问ubuntu系统文件</title>
      <link href="/2018/12/06/%E5%8F%8C%E7%B3%BB%E7%BB%9Fwin10%E8%AE%BF%E9%97%AEubuntu%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6/"/>
      <url>/2018/12/06/%E5%8F%8C%E7%B3%BB%E7%BB%9Fwin10%E8%AE%BF%E9%97%AEubuntu%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时候，我们会在电脑上装win10和ubuntu双系统，但是一般情况下在win10下是看不到ubuntu文件的，那么当我们需要查看ubuntu上文件的时候就只能重启系统了吗？不是的，这里可以给大家推荐一款软件。</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>这款软件就是LinuxReader，它可以在windows系统中访问Ext 2/3/4, UFS2, HFS and ReiserFS/4格式的文件系统，很是方便。网址在这里：</p><p><a href="https://www.diskinternals.com/linux-reader/" target="_blank" rel="noopener">https://www.diskinternals.com/linux-reader/</a></p><h2 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h2><p>打开软件后全貌是这个样子：</p><p><img src="https://hexo-1252865648.cos.ap-chengdu.myqcloud.com/LinuxReader.png" alt="LinuxReader" width="100%" align="middle"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 双系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OS X 10.14å 怎么安装非AppStore的Safari扩展</title>
      <link href="/2018/11/28/OS-X-10.14-%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85%E9%9D%9EAppStore%E7%9A%84Safari%E6%89%A9%E5%B1%95/"/>
      <url>/2018/11/28/OS-X-10.14-%E6%80%8E%E4%B9%88%E5%AE%89%E8%A3%85%E9%9D%9EAppStore%E7%9A%84Safari%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="OS-X-10-14-怎么安装非AppStore的Safari扩展"><a href="#OS-X-10-14-怎么安装非AppStore的Safari扩展" class="headerlink" title="OS X 10.14 怎么安装非AppStore的Safari扩展"></a>OS X 10.14 怎么安装非AppStore的Safari扩展</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自从苹果更新系统后，很多人发现无法通过双击<code>.safariextz</code>文件来安装safari扩展了。所有的扩展都要通过AppStore来安装，所以找到一个可以通过safariextz文件来安装的方法就很重要了。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><blockquote><p>此处以safari翻译扩展Polyglot为例。</p></blockquote><ol><li>将Polyglot.safariextz的后缀名直接改为<code>.zip</code>，也就是<code>Polyglot.zip</code>，双击解压文件会得到一个文件夹。</li><li>如果在第一步中没有得到文件夹，相反是一个文件的话。尝试将文件后缀改为<code>.xar</code>也就是<code>Polyglot.xar</code>再进行解压一般就可以了。</li><li>打开safari浏览器，在设置中显示“开发”菜单。</li><li>在开发菜单中选择，“打开扩展构建器”。</li><li>进入以后点击+号将刚刚解压的文件夹导入就可以了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Safari </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>colab读写外部文件的四种方式</title>
      <link href="/2018/10/20/colab%E8%AF%BB%E5%86%99%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/10/20/colab%E8%AF%BB%E5%86%99%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知，colab是google提供的运行在云端的jupyter notebook环境。里面集成了许多著名的机器学习python库。由于这个环境是运行在google虚拟机上的，显然与自己的pc不在一个文件系统。那么怎么与我们自己的文件交互呢？</p><p>colab文档里提供了四种方式，分别是：</p><ol><li>从本地直接上传</li><li>连接Google Drive</li><li>连接Google Sheet</li><li>连接Google Cloud Storage</li></ol><p>下面就来分别描述。</p><h3 id="与本地文件交互"><a href="#与本地文件交互" class="headerlink" title="与本地文件交互"></a>与本地文件交互</h3><h4 id="本地文件上传"><a href="#本地文件上传" class="headerlink" title="本地文件上传"></a>本地文件上传</h4><p><code>files.upload()</code> 返回一个由我们上传的所有文件构成的一个字典。 这个字典的<code>key</code>是文件名, 这个字典的<code>value</code>是我们上传的文件的<code>data</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> files</span><br><span class="line"></span><br><span class="line">uploaded = files.upload()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fn <span class="keyword">in</span> uploaded.keys():</span><br><span class="line">    print(<span class="string">'User uploaded file "&#123;name&#125;" with length &#123;length&#125; bytes'</span>.format(name=fn, length=len(uploaded[fn])))</span><br></pre></td></tr></table></figure></p><h4 id="从colab下载文件到本地"><a href="#从colab下载文件到本地" class="headerlink" title="从colab下载文件到本地"></a>从colab下载文件到本地</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> files</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">      f.write(<span class="string">'some content'</span>)</span><br><span class="line">files.download(<span class="string">'example.txt'</span>)</span><br></pre></td></tr></table></figure><h3 id="连接Google-Drive"><a href="#连接Google-Drive" class="headerlink" title="连接Google Drive"></a>连接Google Drive</h3><p>这里官方有提供了许多种方法。这里我就挑一种介绍了，有兴趣的可以点进这个<a href="https://colab.research.google.com/notebooks/io.ipynb#scrollTo=P3KX0Sm0E2sF" target="_blank" rel="noopener">链接</a>进去看。</p><p>这里只介绍使用<code>PyDrive</code>的方法。PyDrive是google-api-python-client的包装库，简化了许多常见的Google Drive API任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">!pip install -U -q PyDrive</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pydrive.auth <span class="keyword">import</span> GoogleAuth</span><br><span class="line"><span class="keyword">from</span> pydrive.drive <span class="keyword">import</span> GoogleDrive</span><br><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> auth</span><br><span class="line"><span class="keyword">from</span> oauth2client.client <span class="keyword">import</span> GoogleCredentials</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 验证身份并创建pydrive客户端.</span></span><br><span class="line">auth.authenticate_user()</span><br><span class="line">gauth = GoogleAuth()</span><br><span class="line">gauth.credentials = GoogleCredentials.get_application_default()</span><br><span class="line">drive = GoogleDrive(gauth)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PyDrive 参考:</span></span><br><span class="line"><span class="comment"># https://gsuitedevs.github.io/PyDrive/docs/build/html/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建并上传一个文本文档.</span></span><br><span class="line">uploaded = drive.CreateFile(&#123;<span class="string">'title'</span>: <span class="string">'Sample upload.txt'</span>&#125;)</span><br><span class="line">uploaded.SetContentString(<span class="string">'Sample upload file content'</span>)</span><br><span class="line">uploaded.Upload()</span><br><span class="line">print(<span class="string">'Uploaded file with ID &#123;&#125;'</span>.format(uploaded.get(<span class="string">'id'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 通过id访问文件并输出它的内容.</span></span><br><span class="line">downloaded = drive.CreateFile(&#123;<span class="string">'id'</span>: uploaded.get(<span class="string">'id'</span>)&#125;)</span><br><span class="line">print(<span class="string">'Downloaded content "&#123;&#125;"'</span>.format(downloaded.GetContentString()))</span><br></pre></td></tr></table></figure><h3 id="连接Google-Sheet"><a href="#连接Google-Sheet" class="headerlink" title="连接Google Sheet"></a>连接Google Sheet</h3><h3 id="连接Google-Cloud-Storage"><a href="#连接Google-Cloud-Storage" class="headerlink" title="连接Google Cloud Storage"></a>连接Google Cloud Storage</h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> colab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阮一峰JS学习笔记</title>
      <link href="/2018/10/14/%E9%98%AE%E4%B8%80%E5%B3%B0JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/14/%E9%98%AE%E4%B8%80%E5%B3%B0JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="阮一峰JS学习笔记"><a href="#阮一峰JS学习笔记" class="headerlink" title="阮一峰JS学习笔记"></a>阮一峰JS学习笔记</h1><h2 id="什么是JS"><a href="#什么是JS" class="headerlink" title="什么是JS"></a>什么是JS</h2><p>它是脚本语言，即不具备开发操作系统的能力，而是只用来编写<strong>控制</strong>其他大型应用程序的”脚本“（比如浏览器）。它是嵌入式语言，即没有IO，只能嵌入更大型得应用程序中，去调用宿主环境的IO。（浏览器、node）</p><h2 id="JS都包括什么"><a href="#JS都包括什么" class="headerlink" title="JS都包括什么"></a>JS都包括什么</h2><p>其核心语法相当精简，只包括两部分：</p><ul><li>基本的语法构造<ul><li>操作符</li><li>控制结构</li><li>语句</li></ul></li><li>标准库</li></ul><p>除此之外，因为它要有宿主环境，所以就是一系列宿主环境的API。</p><h2 id="JS难在哪"><a href="#JS难在哪" class="headerlink" title="JS难在哪"></a>JS难在哪</h2><ul><li>它涉及大量的外部API</li><li>JS有不少设计缺陷，某些地方相当不合理。</li></ul><h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="语句and表达式"><a href="#语句and表达式" class="headerlink" title="语句and表达式"></a>语句and表达式</h3><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>指为了<strong>得到返回值的</strong>计算式。</p><p>两者的区别在于，语句一般是为了进行某种操作，改编程序运行状态，一般不需要返回值；而表达式是为了得到返回值，其一定会返回一个值。凡是JS中<strong>预期为一个值的</strong>地方，都可以放置表达式。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是对值旳<strong>具名引用</strong>。</p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JS引擎的工作方式是：<strong>先</strong>解析代码，<strong>获取所有的被声明的变量</strong>，然后再一行一行的运行。这样也就是，所有变量声明的语句，都会被提升到代码头部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>真正运行的是如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>也就是用来识别各种值的合法名称。最常见的标识符就是<strong>变量名</strong>，以及<strong>函数名</strong>。</p><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>对于<code>var</code>命令来说，<code>{ }</code>构成的区块不构成单独的作用域。</p><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h4><p>多个<code>if--else</code>结构连在一起的时候，可使用更简单的<code>switch</code>结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"banana"</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"apple"</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>JS语言允许语句的前面有标签。相当于定位符。<br>通常与<code>break</code>和<code>continue</code>配合使用，跳出特定循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...)&#123;</span><br><span class="line">            <span class="keyword">if</span>(...)&#123;</span><br><span class="line">                <span class="keyword">break</span> top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接跳出外层循环，如果加标签，只默认跳出当前循环。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>数值：整数和小数</li><li>字符串</li><li>布尔值</li><li>undefined 未定义</li><li>null 空值</li><li>对象</li></ul><p>注：前三个成为”原始类型的值”，也就是不能再细分了。对象则是“合成类型”的值。至于那两个英文的，就是特殊值。</p><p>而至于<strong>对象</strong>，又可以分为三类：</p><ul><li>狭义的对象 object</li><li>数组 array</li><li>函数 function</li></ul><h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><p>这是<strong>运算符</strong>！</p><p>预告一下，JS共有三种方式可以确定一个值是什么类型的：</p><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li>Object.prototype.toString 方法</li></ul><h3 id="null-undefined-布尔"><a href="#null-undefined-布尔" class="headerlink" title="null, undefined, 布尔"></a>null, undefined, 布尔</h3><p>null表示值为空值，比如一个参数表示抛出的错误参数，如果此处无错，就会抛出<code>null</code>。</p><p>undefined表示未定义</p><p>关于布尔值，注意类型转换，空字符串转换为<code>false</code>而空数组和空对象则都是<code>true</code>。</p><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>注意，JS里的所有数字都是64位浮动点数存储。所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h4><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串转为整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">//123</span></span><br></pre></td></tr></table></figure><h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h5><p>将字符串转换为浮点数。</p><h5 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h5><p>判断一个值是不是<code>NaN</code>。</p><h5 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h5><p>判断一个数值是不是一个正常的数值。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以像数组一样访问，但是不可以修改单个字符，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">//这样是改变不了的</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h4><ul><li>对象的所有键名都是字符串，所以是否加引号都可以。如果键名是数值，也会被自动转换成字符串。但是如果键名不符合明明规范，则必须加上引号，否则会报错。</li><li>键名又称为属性。它的值可以是任意类型，如果是函数，则这个属性又称为方法。</li><li>值如果是对象，则形成了链式引用。</li></ul><h4 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h4><p>如果不同变量名指向同一个变量，那么他们都是这个对象的引用，也就是指向相同的内存地址。改一个，其他的都会变。</p><p><strong>注意：</strong>这种引用仅限于对象，如果是<strong>原始类型的值</strong>的话，那么变量就是值的<strong>拷贝</strong>。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>有两种运算符，一个是点运算符，另一个就是方括号运算符。</li><li>需要查看一个对象的所有属性，可以使用`Object.keys(yourObj)’方法。</li><li><p>属性的删除，使用<code>delete</code>命令。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.p</span><br></pre></td></tr></table></figure></li><li><p>要查看属性是否存在，可使用<code>in</code>运算符。即使是继承的属性，也会返回<code>true</code>。如果不需要继承，看下一条</p></li><li>判断自身属性，可使用<code>hasOwnProperty()</code>方法来判断。</li><li><p>怎么遍历对象的全部属性，可以使用<code>for...in...</code>循环。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> onj) &#123;</span><br><span class="line">    f(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意，会遍历继承的属性。但是必须是<strong>可遍历的对象</strong>。</p><p>  如果想遍历自身的属性，那么可以结合<code>hasOwnProperty()</code>方法判断一下。</p><h4 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(对象)&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样提供的一种便利就是，在操作一个对象的多个属性时，会方便许多。</p><p>注意，<code>with</code>区块不会改变作用域，所以如果要给一个新属性赋值，需要先有这个属性才行。</p><p><strong>建议：</strong>不要使用<code>with</code>，可以使用一个临时变量来代替这种功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(obj1.obj2.obj3) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3;</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>三种方法</p><ol><li>function命令—函数的声明</li><li>函数表达式—变量赋值的写法，将匿名函数赋值给一个变量，这个匿名函数又叫<strong>函数表达式</strong>。</li><li>Function构造函数—几乎无人使用，不管了</li></ol><h4 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h4><p>函数在js中只是一种可以执行的值而已，与其他值无特殊之处。凡是可以使用值得地方，都可以使用函数。</p><h4 id="函数名得提升"><a href="#函数名得提升" class="headerlink" title="函数名得提升"></a>函数名得提升</h4><p>因为函数名就是变量名，所以使用<code>function</code>命里声明函数的时候，整个函数就会像变量声明一样，被提升到顶部。</p><h4 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h4><ul><li><p>name属性<br>  主要作用：获取作为参数得函数的名字。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) <span class="comment">//得到myFunc</span></span><br></pre></td></tr></table></figure></li><li><p>length属性<br>  返回函数预期传入的<strong>参数的个数</strong>，即函数定义中的参数个数。<br>  其作用可实现方法的<strong>重载</strong>。</p></li><li>toString()<br>  返回一个字符串，内容是函数的源码。<br>  其作用可以实现多行字符串。</li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在js中只有两种作用域，一个是<strong>全局作用域</strong>，另一个就是<strong>函数作用域</strong>。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p>关于函数值得传递方式</p><ul><li>函数参数如果是原始类型得值，那么就<strong>按值传递</strong>。也就是说在函数体内修改参数值，不会影响到函数外部。    </li><li>如果函数参数是复合类型-（数组、对象、函数）的值，那么传递方式就是传址传递。</li><li><p>这里有一个小点需要注意一下就是，如果在函数体内部修改了整个参数的值，而不是某个属性。那么原对象的值是不会被修改的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1.</span> <span class="number">2.</span> <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这里，直接让参数o指向了另外一个对象，保存在原地址上的值当然不会受影响。</p><h4 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h4><p>只在函数体内部可以使用，这个对象包含了函数运行时的所有参数。<code>arguments[0]</code>是第一个参数。<br>    <code>arguments</code>对象含有一个<code>callee</code>属性返回它所对应的函数。</p><h4 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h4><ul><li>闭包：也就是能够读取其他函数内部变量的函数。<ul><li>小引例：因为js内层的函数可以读取外层函数的变量，而外层函数却能读取内部函数的变量，所以要想实现读取某个内部函数的变量可以通过下面这个函数实现<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">//99</span></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>这样就可以拐弯抹角的实现这个功能了。</p><ul><li>闭包在这里就是这个函数<code>f2</code> , 他也就是将内部变量和外部变量相互链接的桥梁。</li><li>闭包有两个作用<ul><li>一个是可以让外部函数访问内部函数的变量</li><li>第二就是可以让运行环境保存住函数内部的变量</li></ul></li><li>闭包还可以封装对象的私有属性和私有方法</li><li>闭包会保留外层函数的内部变量，造成内存消耗，不能滥用。</li><li>立即调用的函数表达式<br>这里有一个很有意思的点，就是<code>function(){}</code>既可以当语句又可以当表达式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>所以为了能够区分，js引擎就认为<code>function</code>出现在行首就是一个语句。<br>但是加个括号阔起来就可以让引擎认为是一个表达式了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;...&#125;)();<span class="comment">//这样就可以直接调用函数了。</span></span><br></pre></td></tr></table></figure></p><p>为了避免污染全局变量，经常会直接调用匿名函数。</p><h4 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h4><p>eval接受一个字符串作为参数，并将这个字符串当做语句执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = q'</span>);</span><br><span class="line">a <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>会影响当前作用域的变量，不推荐使用。一般用来解析JSON但是JSON最好还是用<code>JSON.parse</code>方法。<br><strong>注意：</strong>只有<code>eval()</code>这一种形式属于直接调用，剩下的全属于别名调用，别名调用的<code>eval()</code>通通影响的事<strong>全局</strong>作用域。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tyoeof [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><p>可见数组的类型就是对象，那么数组有什么不同呢，数组的特殊性就体现在它的键名是按次序排列的一组整数<code>(0,1,2...)</code>。</p><p>但是读取的时候，对于数组的键名，不能使用点号读取。（因为数字开头不是合法的标识符）。</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li>length属性</li><li>in 运算符</li><li>for … in … 循环和数组遍历<ul><li>注意，这个不仅会遍历数组的数字键，还会遍历非数字键。</li><li>所以不推荐使用</li></ul></li><li>那么想简历数组最好使用<code>for</code>OR<code>while</code>循环。</li><li>数组的<code>forEach()</code>方法也能<strong>遍历数组</strong>。<h4 id="空位"><a href="#空位" class="headerlink" title="空位"></a>空位</h4>空位不同于<code>undefined</code>，遍历数组是，空位不会被遍历。<h4 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h4>只要有<code>length</code>属性，就可以认为是类似数组对象，但是它不是数组。要想将其转换为数组可以使用数组的<code>slice()</code>方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure><p>使用<code>call()</code>方法可以对类似数组的对象使用数组的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure><p>这样就可以让<code>arrayLike</code>使用<code>forEach</code>方法。</p><p>实际使用中最好还是先转成数组再使用。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>注意强制类型转换Number()和parseInt的区别<ul><li>Number()函数比parseInt()函数要严格很多。基本上，只要有一个字符无法转成述职，整个字符串就是<code>NaN</code>。而，<code>parseInt()</code>却可以将前几个是数字的字符提取出来。</li></ul></li><li>自动转换的规则<ul><li>预期是什么类型的值，就调用该类型得转换函数。<h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><h4 id="Error构造函数"><a href="#Error构造函数" class="headerlink" title="Error构造函数"></a>Error构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错信息'</span>);</span><br><span class="line">err.message <span class="comment">// "出错信息"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>此外还有几个派生的错误类</p><ul><li>SyntaxError</li><li>ReferenceError</li><li>RangeError</li><li>TypeError</li><li>URIError</li><li>EvalError</li><li>自定义错误类型（继承自Error）</li></ul><h4 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h4><p>作用是手动<strong>中断程序</strong>执行，抛出一个错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'x必须为正数'</span>); <span class="comment">//这里抛出一个错误对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="try…catch结构"><a href="#try…catch结构" class="headerlink" title="try…catch结构"></a>try…catch结构</h4><p>发生错误后可以对错误进行处理，捕捉错误，并决定是否执行下去。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error occured'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123; <span class="comment">// 这里的参数e就是捕获上面那个try返回的错误对象（这里为了产生错误，强行用了throw语句）</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">    <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p><code>try...catch</code>后面还可以跟一个<code>finally</code>代码块，<strong>无论是否出现错误</strong>，都会执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanUp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error occured'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'此行不会执行'</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'完成清理工作'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleanUp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Error: error occured</span></span><br></pre></td></tr></table></figure></p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><p>JS其他所有对象都是<strong>继承</strong>自<code>Object</code>对象，即都是<code>Object</code>的<strong>实例</strong>。</p><h4 id="原生方法"><a href="#原生方法" class="headerlink" title="原生方法"></a>原生方法</h4><ul><li><p>一类是<code>Object</code>本身的方法，</p><ul><li>即直接定义在Object对象上</li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; <span class="built_in">console</span>.log(o)&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>还有一类就是<code>Object</code>的实例方法。</p><ul><li>即定义在Object原型对象<code>Object.prototype</code>上的方法。可以被Object实例直接使用。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.print()</span><br></pre></td></tr></table></figure><ul><li>obj会直接继承 <code>Object.prototype</code> 上的方法.</li></ul><h4 id="将Object-看为一个普通函数（工具函数）"><a href="#将Object-看为一个普通函数（工具函数）" class="headerlink" title="将Object()看为一个普通函数（工具函数）"></a>将Object()看为一个普通函数（工具函数）</h4><p>功能1：将任意值转换为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>功能2：判断某个变量是不是对象。因为Object有一个特点，就是当他的参数本身就是个对象的话，那么返回的还是原变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(arr); <span class="comment">// 返回原数组</span></span><br><span class="line">obj === arr <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="当Object-是构造函数时"><a href="#当Object-是构造函数时" class="headerlink" title="当Object()是构造函数时"></a>当Object()是构造函数时</h4><p>即前面可以使用<code>new</code>命令。使用方法几乎等同于工具函数Object()，但是语义不一样。工具函数是指<strong>转换</strong>成对象。</p><h4 id="Object静态方法（即将Object看成一个普通的对象）"><a href="#Object静态方法（即将Object看成一个普通的对象）" class="headerlink" title="Object静态方法（即将Object看成一个普通的对象）"></a>Object静态方法（即将Object看成一个普通的对象）</h4><p>即部署在Object对象自身的方法。</p><h5 id="遍历对象的属性"><a href="#遍历对象的属性" class="headerlink" title="遍历对象的属性"></a>遍历对象的属性</h5><ul><li>Object.keys()</li><li>Object.getOwnPropertyNames()</li></ul><p>这两个的参数都是一个对象。区别在于，keys只返回可枚举的属性，而getOwnPropertyNames方法还可以返回补课枚举的属性。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>对象属性模型的相关方法</li><li>控制对象状态的方法</li><li>原型链相关方法</li></ul><h4 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h4><p>也就是定义在Object.prototype对象上的方法。所有Object的实例对象都继承了这些方法。</p><h5 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h5><p>返回一个对象的值，默认返回对象本身。其主要作用在于，自动类型转换时会<strong>调用</strong>。</p><h5 id="Obbject-prototype-toString"><a href="#Obbject-prototype-toString" class="headerlink" title="Obbject.prototype.toString()"></a>Obbject.prototype.toString()</h5><p>返回一个对象的字符串形式。默认返回<strong>类型</strong>字符串。也用于自动类型转换。可以得到想要的字符串形式。<br><strong>注意，</strong>这些函数有可能被用户重写，如果依然想调用，最好使用<code>Object.prototype.toString.call()</code>方法。<br>可以用于判断类型以及构造函数。这样会比<code>typeof</code>运算符更精确。</p><h5 id="Object-prototype-toLocalString"><a href="#Object-prototype-toLocalString" class="headerlink" title="Object.prototype.toLocalString()"></a>Object.prototype.toLocalString()</h5><p>与<code>toString</code>基本相同，也是返回字符串，但是可以加上一些用户的信息。比如返回日期的实例类型对象时，就和地域相关。</p><h5 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h5><p>返回一个布尔值，表示该实例对象自身是否具有该属性。</p><h3 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h3><p>是一种数据结构，用来描述某个属性是否可写、可遍历等。每个属性都有自己的属性描述对象。</p><h4 id="Object-getOwnPropertyDescription"><a href="#Object-getOwnPropertyDescription" class="headerlink" title="Object.getOwnPropertyDescription()"></a>Object.getOwnPropertyDescription()</h4><p>获取属性描述对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescription()</span><br></pre></td></tr></table></figure><h4 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>Object.getOwnPropertyNames()</li><li>Object.defineProkperty()</li><li>Object.defineProperties()</li><li>Object.prototype.propertyIsEnumerable()</li></ul><h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p>也就是属性描述对象的属性</p><ul><li>value</li><li>writable</li><li>enumerable — 可以用来设置私密属性，只是不可以遍历到，但是还是可以访问的。如果要获取自身的所有属性（不管是否可遍历，都可以使用getOwnPropertyNames）</li><li>configurable – 是否可以修改属性描述对象</li><li><p>getter/setter – 存取器</p><p>  存取器有两种写法，一个是在键<code>get</code>和<code>set</code>的后面直接给出值。另一种是<code>get p() {}</code>和<code>set p(value) {}</code></p></li></ul><h4 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h4><p>这里要注意的是，怎么拷贝过来get()属性等。</p><h4 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h4><ul><li>Object.preventExtentions()</li><li>Object.isExtensible()</li><li>Object.seal()</li><li>Object.isSealed()</li><li>Object.freeze()</li><li>Object.isFrozen()</li></ul><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><p><code>Array</code>是JS的原生<strong>对象</strong>，同时也是<strong>构造函数</strong>。</p><p>因为当Array构造函数的参数不同时，他的行为很不一致，所以最好直接使用数组字面量来创建新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad </span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//good </span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><h5 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h5><p>可以弥补<code>typeof</code>运算符的不足。</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li>valueOf()</li><li>toString()</li><li>push(), pop()</li><li>shift(), unshift()</li><li>join()—连接数组成员为字符串（可以自定义分隔符）</li><li>concat() —— 用于多个数组的合并</li><li>reverse()</li><li>slice() - arr.slice(start, end) –提取</li><li>splice() - arr.splice(start, end, addElem1, addElem2 ,….)删除，并且可以在删除的位置添加。返回值是被删除的元素。</li><li>sort()</li><li>map()</li><li>forEach()</li><li>filter()</li><li>some(), every()</li><li>reduce(), reduceRight()</li><li>indexOf(), lastIndexOf</li></ul><h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>就是将三种原始数据类型的值（数值、字符串、布尔值）包装为对象。</p><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>可以从两个方面来理解：</p><ul><li>对象时<strong>单个实物</strong>的抽象。</li><li>对象是一个<strong>容器</strong>，封装了属性和方法。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>JS与C++不同，没有类的概念，也就是他不是基于类的，而是基于<strong>构造函数（constructor）</strong>和<strong>原型链（prototype）</strong>。JS使用构造函数作为对象的<strong>模板</strong>。一个构造函数，可以生成多个实例对象。</p><p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了与普通函数区别，构造函数名字的第一个字母通常大写。</p><p>new命令：因为new命令本身就可以执行函数，不再需要函数的调用，所以可以不加括号执行，但是还是推荐加括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle;</span><br></pre></td></tr></table></figure><p>如果不使用<code>new</code>命令，而直接调用构造函数，会发生：构造函数变为普通函数，不会再生成实例对象，这里的<code>this</code>也将会代表全局对象。</p><h4 id="new命令执行过程"><a href="#new命令执行过程" class="headerlink" title="new命令执行过程"></a>new命令执行过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">constructor, plarams</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将arguments对象转为数组</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//取出构造函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = args.shift();</span><br><span class="line">    //创建一个空对象，继承构造函数的prototype属性</span><br><span class="line">    var context = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">    //执行构造函数</span><br><span class="line">    var result = <span class="keyword">constructor</span>.apply(context, args);</span><br><span class="line">    //如果返回结果是对象，就直接返回，否则返回context对象。</span><br><span class="line">    return (typeof result === 'object' &amp;&amp; result != null) ? result:context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例</span><br><span class="line">var actor = _new(Person, '张三', 28);</span><br></pre></td></tr></table></figure><h3 id="实例化对象的另一个方法Object-create"><a href="#实例化对象的另一个方法Object-create" class="headerlink" title="实例化对象的另一个方法Object.create()"></a>实例化对象的另一个方法Object.create()</h3><p>在拿不到构造函数，而只能拿到一个现有的对象的时候，我们可以以这个对象为模板，来生成新的实例对象。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己构建Docker镜像在自己的服务器上搭建支持C++和tensorflow的jupyter-notebook</title>
      <link href="/2018/07/28/%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%94%AF%E6%8C%81C++%E5%92%8Ctensorflow%E7%9A%84jupyter-notebook/"/>
      <url>/2018/07/28/%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%94%AF%E6%8C%81C++%E5%92%8Ctensorflow%E7%9A%84jupyter-notebook/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Docker软件"><a href="#安装Docker软件" class="headerlink" title="安装Docker软件"></a>安装Docker软件</h2><p>不再赘述，可参考本博客中以前的文章。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>github地址：</p><p><a href="https://github.com/heliuphy/myDockerRepo/blob/master/jupyter-cling/Dockerfile" target="_blank" rel="noopener">https://github.com/heliuphy/myDockerRepo/blob/master/jupyter-cling/Dockerfile</a></p><h2 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name jupyter-cling \</span><br><span class="line">-p 9002:8888 \</span><br><span class="line">--user root \</span><br><span class="line">-e GRANT_SUDO=yes \</span><br><span class="line">-e NB_UID=1001 \</span><br><span class="line">-e NB_GID=101 \</span><br><span class="line">-v /home/jupyter-cling:/home/jovyan/work \</span><br><span class="line">heliuphy/jupyter-cling start-notebook.sh \</span><br><span class="line">--NotebookApp.password=<span class="string">'sha1:********'</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># 增加 NB_UID 对目录的权限</span></span><br><span class="line">$ chown 1001 /home/jupyter-cling</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
            <tag> c++ </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四步安装好支持tensorflow和C++的Jupyter-notebook</title>
      <link href="/2018/07/26/%E5%9B%9B%E6%AD%A5%E5%AE%89%E8%A3%85%E5%A5%BD%E6%94%AF%E6%8C%81tensorflow%E5%92%8CC++%E7%9A%84Jupyter-notebook/"/>
      <url>/2018/07/26/%E5%9B%9B%E6%AD%A5%E5%AE%89%E8%A3%85%E5%A5%BD%E6%94%AF%E6%8C%81tensorflow%E5%92%8CC++%E7%9A%84Jupyter-notebook/</url>
      
        <content type="html"><![CDATA[<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update <span class="comment"># Ubuntu</span></span><br><span class="line">sudo apt-get install docker</span><br></pre></td></tr></table></figure><h2 id="使用docker安装tensorflow-jupyter"><a href="#使用docker安装tensorflow-jupyter" class="headerlink" title="使用docker安装tensorflow-jupyter"></a>使用docker安装tensorflow-jupyter</h2><blockquote><p>参考网址        <a href="https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html" target="_blank" rel="noopener">https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name jupyter \</span><br><span class="line">-p 9001:8888 \</span><br><span class="line">--user root \</span><br><span class="line">-e GRANT_SUDO=yes \</span><br><span class="line">-e NB_UID=1000 \</span><br><span class="line">-e NB_GID=100 \</span><br><span class="line">-v /home/jupyter:/home/jovyan/work \</span><br><span class="line">jupyter/tensorflow-notebook start-notebook.sh \</span><br><span class="line">--NotebookApp.password=<span class="string">'sha1:********'</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><p>\ 表示换行，把一条命令拆成多行以方便阅读<br>-d 表示启动的容器进入到后台运行；<br>-p 表示指定端口，这里把宿主机的 8888 端口映射到容器的 8888 端口；<br>–user=root，允许运行 sudo；<br>-e 指定 jovyan 用户相关权限 ID；<br>–name 表示给启动的容器设定名字;<br>-v 表示把宿主机的目录挂载到容器中。Jupyter Docker 的文档目录是 /home/jovyan/work，为了使得容器被销毁时，文档不受影响，将本地目录 /home/local/jupyter 挂载到 /home/jovyan/work;<br>-NotebookApp.password 是登录的密码，可以在 Ipython 中使用如下命令生成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">In [<span class="number">2</span>]: passwd()</span><br><span class="line">Enter password: ****</span><br><span class="line">Verify password: ****</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'sha1:********'</span></span><br></pre></td></tr></table></figure></p><h2 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h2><p>按照以上网址安装好后可以通过<a href="http://ip:9001访问自己的jupyter" target="_blank" rel="noopener">http://ip:9001访问自己的jupyter</a> notebook 。 但是带个端口号总是很别扭，所以这里通过Nginx来反向代理。<br>步骤如下：<br>通过 nginx -t 命令找到 Nginx 的配置文件地址。在 nginx.conf 文件中，新增如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">upstream notebook &#123;</span><br><span class="line">    server localhost:8888;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name yourdomain.com;</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass            http://notebook;</span><br><span class="line">    proxy_set_header      Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">location ~ /api/kernels/ &#123;</span><br><span class="line">    proxy_pass            http://notebook;</span><br><span class="line">    proxy_set_header      Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="comment"># websocket support</span></span><br><span class="line">    proxy_http_version    1.1;</span><br><span class="line">    proxy_set_header      Upgrade <span class="string">"websocket"</span>;</span><br><span class="line">    proxy_set_header      Connection <span class="string">"Upgrade"</span>;</span><br><span class="line">    proxy_read_timeout    86400;</span><br><span class="line">    &#125;</span><br><span class="line">location ~ /terminals/ &#123;</span><br><span class="line">    proxy_pass            http://notebook;</span><br><span class="line">    proxy_set_header      Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="comment"># websocket support</span></span><br><span class="line">    proxy_http_version    1.1;</span><br><span class="line">    proxy_set_header      Upgrade <span class="string">"websocket"</span>;</span><br><span class="line">    proxy_set_header      Connection <span class="string">"Upgrade"</span>;</span><br><span class="line">    proxy_read_timeout    86400;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>nginx -s reload</code> ，重启 Nginx 服务后生效。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Jupyter 的基本单元是编程 cell 组成，也就是一个 <code>In[ ]</code>:</p><p>Jupyter 有三种类型的 cells：<code>code</code>，<code>markdown cells</code>，<code>raw cells</code>，常用的是 code cells 和 markdown cells 类型。</p><p>Cells 状态分为命令模式和编辑模式，Enter 进入编辑模式，ESC 进入命令模式，命令模式和编辑模式下支持很多操作快捷键。</p><p>常用命令模式快捷键：</p><ul><li>y: 单元进入代码状态</li><li>m: 转入markdown状态</li><li>r：转入raw状态</li><li>a: 上方插入新单元</li><li>b：下方插入新单元</li><li>x：剪切选中单元</li><li>c: 复制选中单元</li><li>shift-v：粘贴到上方单元</li></ul><h3 id="插入-Markdown"><a href="#插入-Markdown" class="headerlink" title="插入 Markdown"></a>插入 Markdown</h3><p>直接输入 Markdown ，然后 Run 即可渲染结果。支持标题，文本，视频，图片等。</p><h3 id="插入-LaTeX-公式"><a href="#插入-LaTeX-公式" class="headerlink" title="插入 LaTeX 公式"></a>插入 LaTeX 公式</h3><ul><li><p>创建行内公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$</span><br></pre></td></tr></table></figure></li><li><p>块级公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>可以直接在页面输出代码块，只需要在前后加上<code>代码块</code>即可。</p><h3 id="嵌入图片"><a href="#嵌入图片" class="headerlink" title="嵌入图片"></a>嵌入图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import Image</span><br><span class="line">Image(filename=&quot;yourpath.jpg&quot;)</span><br></pre></td></tr></table></figure><h3 id="嵌入音乐"><a href="#嵌入音乐" class="headerlink" title="嵌入音乐"></a>嵌入音乐</h3><p>可以嵌入本地音乐和网络音乐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import Audio</span><br><span class="line">Audio(filename=&quot;yourpath.wma&quot;)</span><br><span class="line">from IPython.display import Audio</span><br><span class="line">Audio(url=&quot;http://yourpath.wma&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="嵌入本地视频"><a href="#嵌入本地视频" class="headerlink" title="嵌入本地视频"></a>嵌入本地视频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import io</span><br><span class="line">import base64</span><br><span class="line">from IPython.display import HTML</span><br><span class="line">video = io.open(&apos;/home/test.mp4&apos;, &apos;r+b&apos;).read()</span><br><span class="line">encoded = base64.b64encode(video)</span><br><span class="line">HTML(data=&apos;&apos;&apos;&lt;video alt=&quot;test&quot; controls&gt;</span><br><span class="line">     &lt;source src=&quot;data:video/mp4;base64,&#123;0&#125;&quot; type=&quot;video/mp4&quot; /&gt;</span><br><span class="line">     &lt;/video&gt;&apos;&apos;&apos;.format(encoded.decode(&apos;ascii&apos;)))</span><br></pre></td></tr></table></figure><h3 id="嵌入网页"><a href="#嵌入网页" class="headerlink" title="嵌入网页"></a>嵌入网页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import IFrame</span><br><span class="line">IFrame(&apos;http://yourpath.com&apos;, width=&apos;100%&apos;, height=350)</span><br></pre></td></tr></table></figure><h3 id="嵌入链接"><a href="#嵌入链接" class="headerlink" title="嵌入链接"></a>嵌入链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import FileLink</span><br><span class="line">FileLink(&apos;./test/a.ipynb&apos;)</span><br></pre></td></tr></table></figure><h3 id="魔法命令"><a href="#魔法命令" class="headerlink" title="魔法命令"></a>魔法命令</h3><p>所有以 <code>%</code> 开头的方法，都是所谓的魔术方法 (Magic function)，也就是 IPython 内置的一些方法。需要注意的是，魔术方法有%和 %% 之分，比如 <code>%timeit</code> 和 <code>%% timeit</code>。在 IPython 中有专门的叫法，前者叫 <code>line magic</code> 后者叫<code>cell magic</code>。顾名思义，前者是专门针对一行的命令，后者针对多行的命令。<br>通过 <code>%lsmagic</code>可以查看所有的 magic 命令，使用 <code>?</code> 或者 <code>??</code> 可以查看该命令的信息，后者可以查看源码。如： <code>%alias?</code>，会出现该方法的描述。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html" target="_blank" rel="noopener">https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html</a><br><a href="https://github.com/jupyter/docker-stacks" target="_blank" rel="noopener">https://github.com/jupyter/docker-stacks</a><br><a href="http://www.cnblogs.com/giserliu/p/4997144.html" target="_blank" rel="noopener">http://www.cnblogs.com/giserliu/p/4997144.html</a></p><hr><h2 id="安装C-环境"><a href="#安装C-环境" class="headerlink" title="安装C++环境"></a>安装C++环境</h2><blockquote><p><a href="https://github.com/QuantStack/xeus-cling" target="_blank" rel="noopener">https://github.com/QuantStack/xeus-cling</a></p></blockquote><ul><li>安装<br>xeus-cling已经在linux和OS X平台上为conda包管理器打包。<br>为确保安装正常，最好安装xeus-cling在新的conda环境中。还需要使用miniconda安装，因为使用完整的anaconda，您可能会与zeromq已安装在anaconda发行版中的库发生冲突。<br>最安全的用法是创建一个以clingminiconda安装命名的环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n cling</span><br><span class="line"><span class="built_in">source</span> activate cling</span><br></pre></td></tr></table></figure><p>然后，您可以在此环境xeus-cling及其依赖项中安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install xeus-cling notebook -c QuantStack -c conda-forge</span><br></pre></td></tr></table></figure></p><p>或者，如果已经安装了所有依赖项，则可以直接从源安装它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX = your_conda_path -DCMAKE_INSTALL_LIBDIR = your_conda_path / lib</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><hr><h2 id="附：Jupyter-kernels"><a href="#附：Jupyter-kernels" class="headerlink" title="附：Jupyter-kernels"></a>附：Jupyter-kernels</h2><p><a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
            <tag> python </tag>
            
            <tag> c++ </tag>
            
            <tag> jupyter-notebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>将图片自动上传到七牛并在markdown中引用</title>
      <link href="/2017/05/16/%E5%B0%86%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E5%B9%B6%E5%9C%A8markdown%E4%B8%AD%E5%BC%95%E7%94%A8/"/>
      <url>/2017/05/16/%E5%B0%86%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E5%B9%B6%E5%9C%A8markdown%E4%B8%AD%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Markdown传统的插入图片的步骤实在是让人心累，所以我就上网搜了搜有没有啥简单的解决办法。倒是找到了不少支持自动上传到七牛云的Markdown编辑器，然而大多是只支持OSX,Win用户哭晕在厕所。。。。不过经过一番搜索，还是找到了不少顺手的工具。</p><p>这里推荐两种方式：</p><ol><li>Mpic软件，不管是拖拽上传、复制上传还是截图上传通通都支持，并且可以自动复制，官网地址：<a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">MPic-图床神器</a></li><li>可以借助一个工具，Github地址在这里：<a href="https://github.com/jiwenxing/qiniu-image-tool-win" target="_blank" rel="noopener">qiniu-image-tool-win</a></li></ol><p>这两种方式都可以，由于第一种很简单，这里只介绍第二种方式的配制方法。配置完后，使用起来体验也很好。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>从<a href="https://github.com/jiwenxing/qiniu-image-tool-win/releases" target="_blank" rel="noopener">release</a>页面下载成功后，解压。</li><li>安装AutoHotkey。<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2>编辑<code>qiniu-image-upload.ahk</code>文件，将一下内容做一些修改：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ACCESS_KEY = ***</span><br><span class="line">SECRET_KEY = ***</span><br><span class="line">BUCKET_NAME = ***  ;qiniu bucket name</span><br><span class="line">BUCKET_DOMAIN = http://7xry05.com1.z0.glb.clouddn.com/  ;qiniu domain for the image</span><br><span class="line">WORKING_DIR = E:\TOOLS\qiniu-image-tool-win\  ;directory that you put the qshell.exe</span><br></pre></td></tr></table></figure></li></ol><p>具体的内容请参考原作者博客，点<a href="http://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/" target="_blank" rel="noopener">这里</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装并配置成功后，只需两步即可插入图片到<code>markdown</code>文档中：</p><ol><li><code>Ctrl+c</code>复制图片</li><li><code>Ctrl+Alt+v</code>即可将<code>markdown</code>引用地址粘贴到文档中。<blockquote><p>参考：<a href="http://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/" target="_blank" rel="noopener">http://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/</a><br><a href="https://github.com/jiwenxing/qiniu-image-tool-win" target="_blank" rel="noopener">https://github.com/jiwenxing/qiniu-image-tool-win</a></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Bash编程（一）</title>
      <link href="/2017/05/15/Bash%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/05/15/Bash%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>shell是一个命令解释器，是介于操作系统内核与用户之间的一个绝缘层。准确地说，它也是能力很强的计算机语言，被称为解释性语言或脚本语言。它可以通过将<strong>系统调用、公共程序、工具和编译过的二进制程序</strong>“粘合”在一起来建立应用，这是大多数脚本语言的共同特征，所以有时候脚本语言又叫做“胶水语言”</p><a id="more"></a><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>&gt;</code> 这个符号是重定向,执行以下代码，就会在当前目录下生成一个my.txt。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> echo &quot;Hello World&quot; &gt; my.txt</span><br></pre></td></tr></table></figure></p><h3 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h3><p>如何利用bash将某文件的内容清楚而保留文件？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 初始化一个变量</span><br><span class="line">LOG_DIR=/var/log</span><br><span class="line"></span><br><span class="line">cd $LOG_DIR</span><br><span class="line"></span><br><span class="line">cat /dev/null &gt; messages</span><br><span class="line">cat /dev/null &gt; wtmp</span><br><span class="line"></span><br><span class="line">echo &quot;Logs cleaned up.&quot;</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>注：<br><code>/dev/null</code> 这个东西可以理解为一个黑洞，里面是空的，将这个空文件写入某个文件，里面的内容就被删了。</p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>行首以<code>#</code>开头(除<code>#!</code>之外)的是注释。<code>#!</code>是用于指定当前脚本的解释器，我们这里为<code>bash</code>，且应该指明完整路径，所以为<code>/bin/bash</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;The # here does not begin a comment.&quot;</span><br><span class="line">echo &apos;The # here does not begin a comment.&apos;</span><br><span class="line">echo The \# here does not begin a comment. # \#是转义字符</span><br><span class="line">echo The # 这里开始一个注释</span><br><span class="line">echo $(( 2#101011 ))     # 数制转换（使用二进制表示），不是一个注释，双括号表示对于数字的处理</span><br><span class="line"></span><br><span class="line"># 欢迎来到实验楼参观学习</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo在线编写博客——hexo系列文章（四）</title>
      <link href="/2017/05/10/hexo%E5%9C%A8%E7%BA%BF%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/05/10/hexo%E5%9C%A8%E7%BA%BF%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这篇文章就是在线写出来的~</p><p>从编辑、到生成，全部云上完成，妈妈再也不用担心我在别的电脑上没法写hexo了！</p><a id="more"></a><p>效果如图：</p><p><img src="http://op0n2nyjd.bkt.clouddn.com//nextd/posts/img1705102.jpg" alt="cloud9在线写博客"></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>搭建这个环境其实也并不麻烦啦，Cloud9我是用别人的镜像装的，所以简单很多。总体来说，大概需要这些东西：</p><ul><li>VPS一台</li><li>Docker</li><li>Cloud9</li><li>nvm</li><li>node(建议&gt;6.*)</li><li>npm</li><li>hexo</li><li>apache(可选)</li><li>rsync(可选)</li><li>incrond（可选）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="VPS篇"><a href="#VPS篇" class="headerlink" title="VPS篇"></a>VPS篇</h3><p>我VPS用的系统是CentOS6.8 x64</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>CentOS下安装Docker还是很简单的，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-io</span><br></pre></td></tr></table></figure></p><p>安装完后启动docker服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure></p><h3 id="Cloud9安装（Docker）"><a href="#Cloud9安装（Docker）" class="headerlink" title="Cloud9安装（Docker）"></a>Cloud9安装（Docker）</h3><h4 id="用VPS"><a href="#用VPS" class="headerlink" title="用VPS"></a>用VPS</h4><p><del><strong>注：</strong>dockerhub上现成的image是没有密码的，我可不希望别人谁都可以进来编辑我的博客，所以改一下Dockerfile，自己构建镜像。</del></p><p>不要用这个办法了，dockerhub上有现成的镜像<code>sapk/cloud9</code>，地址<a href="https://hub.docker.com/r/sapk/cloud9/" target="_blank" rel="noopener">点这里</a><br>想看旧方法，请<a href="https://heliublog.com/2017/05/10/hexo%E5%9C%A8%E7%BA%BF%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/#cloud9-docker" target="_blank" rel="noopener">点这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull sapk/cloud9</span><br><span class="line"></span><br><span class="line"># start with auth 将username,password替换成自己的账号密码</span><br><span class="line">docker run -d -v your-path/workspace:/workspace -p 8181:8181 sapk/cloud9 --auth username:password</span><br></pre></td></tr></table></figure><p><a href="http://ip:8181" target="_blank" rel="noopener">http://ip:8181</a>  查看效果吧！</p><h4 id="用Docker云"><a href="#用Docker云" class="headerlink" title="用Docker云"></a>用Docker云</h4><p>这里仅以<a href="https://arukas.io/" target="_blank" rel="noopener">Arukas</a>为例。<br>注册账号什么的就不说了。<br>直接创建应用，按照下图填写就行了：<br><img src="http://op0n2nyjd.bkt.clouddn.com//nextd/posts/img1705112.jpg" alt="Arukas"><br>创建完成后启动应用，如果一次不成功就多试几次。<br>创建成功后，点击<code>Endpoint</code>后面的链接就可以进到你自己的cloud9了。</p><p><strong>千万注意：我不知道这里的数据都储存在了哪里，所以一定要定时将自己的博文通过cloud9页面下载到自己的电脑上，以作备份。</strong></p><h3 id="nvm、node、npm、hexo"><a href="#nvm、node、npm、hexo" class="headerlink" title="nvm、node、npm、hexo"></a>nvm、node、npm、hexo</h3><p>这些我们一起讲，因为都是在cloud9中安装的。</p><h4 id="nvm、node、npm的安装"><a href="#nvm、node、npm的安装" class="headerlink" title="nvm、node、npm的安装"></a>nvm、node、npm的安装</h4><p>nvm是node的版本管理器。</p><h5 id="首先安装必要的包"><a href="#首先安装必要的包" class="headerlink" title="首先安装必要的包"></a>首先安装必要的包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install build-essential libssl-dev</span><br></pre></td></tr></table></figure><p><strong>注意：cloud9镜像是用ubuntu搭建的，所以要用apt-get，这个不是centos系统了，不要弄混了~</strong></p><h5 id="安装nvm的脚本"><a href="#安装nvm的脚本" class="headerlink" title="安装nvm的脚本"></a>安装nvm的脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash</span><br></pre></td></tr></table></figure><h5 id="使用nvm安装并使用node6"><a href="#使用nvm安装并使用node6" class="headerlink" title="使用nvm安装并使用node6"></a>使用nvm安装并使用node6</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install v6.10.3</span><br><span class="line">nvm use v6.10.3</span><br><span class="line">node -v</span><br><span class="line"># v6.10.3  即表示安装成功</span><br></pre></td></tr></table></figure><p>npm有了，就不必装了</p><h4 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h4><blockquote><p>这个不是本文重点，可以参考我以前的文章<br><a href="https://heliublog.com/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener">搭建hexo博客小记——hexo系列文章（一）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">mkdir hexo</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></p></blockquote><p>好了，到此为止，整个在线环境就部署成功了，你可以<code>hexo d</code>来提交你的博客到github，当然，也可以用你的VPS来<br>做网页服务器。如果不想的话，下面的部分就不用看了。</p><hr><h3 id="apache安装"><a href="#apache安装" class="headerlink" title="apache安装"></a>apache安装</h3><p>由于我没学过前端，这里我用的是<a href="https://blog.linuxeye.com/31.html" target="_blank" rel="noopener">lnmp一键安装包</a>，可以只装Apache，别的都不用装。</p><p>将主机目录设置为<code>your-workspace/hexo/public</code></p><p>我的这样做是不行，改了权限也不行，所以只能用默认的目录<code>/data/wwwroot/your-domain-name</code>然后同步两个文件夹了。<br>这是就用到最后两个工具：</p><ul><li>rsync用来同步</li><li>incron用来监控文件改动</li></ul><h3 id="rsync的使用"><a href="#rsync的使用" class="headerlink" title="rsync的使用"></a>rsync的使用</h3><p>使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --delete /ressourcen /ressourcen_backup</span><br></pre></td></tr></table></figure></p><p>这样当<code>/ressourcen</code>目录中的文件有变动、删除时，就会同步到<code>/ressourcen_backup</code>。</p><p>我们要把这个文件写到一个脚本中，这样才能发挥他的作用（后述）。</p><h3 id="incron"><a href="#incron" class="headerlink" title="incron"></a>incron</h3><p>incron的使用，我在前面的文章中也提到过<a href="https://heliublog.com/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#安装incron" target="_blank" rel="noopener">VPS+Hexo+Dropbox创建个人博客</a></p><p>安装incron<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install incron</span><br><span class="line">service incrond start</span><br></pre></td></tr></table></figure></p><p>用incron来监测文件夹变动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrontab -e</span><br><span class="line"># 在其中添加：</span><br><span class="line">your-path/hexo/public IN_MOVE,IN_MODIFY,IN_CREATE,IN_DELETE your-path/runrsync.bash</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim runrsync.bash</span><br></pre></td></tr></table></figure><p>runrsync.bash中写入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">exec 200&lt;$0</span><br><span class="line">flock -n 200 || exit 1</span><br><span class="line">sleep 1</span><br><span class="line">rsync -av --delete /ressourcen /ressourcen_backup</span><br></pre></td></tr></table></figure></p><p>赋予权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x runrsync.bash</span><br></pre></td></tr></table></figure></p><p>这样当<code>hexo g</code>，<code>public</code>文件夹就会发生变动，此时incron检测到了文件变动，运行脚本<code>runrsync.bash</code>，实现两个文件夹的同步。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h3><p>若用国外主机，在<code>hexo new</code>时，会由于时区设置的问题，<code>date</code>显示的不是本地时间，可以更改时区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -R  # 查看当前系统时区</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 设置时区为东八区</span><br></pre></td></tr></table></figure></p><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><p>我们写了很多脚本，运行了很多服务，机器重启之后都不会开起来，所以我们要加入开机自启，才能保证功能的正常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line"></span><br><span class="line"># 写入以下内容</span><br><span class="line"></span><br><span class="line"># Docker</span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line"># cloud9</span><br><span class="line">docker start 3e9a55a</span><br><span class="line"></span><br><span class="line"># incrond</span><br><span class="line">service incrond start</span><br></pre></td></tr></table></figure></p><h2 id="old"><a href="#old" class="headerlink" title="old"></a>old</h2><h3 id="cloud9-docker"><a href="#cloud9-docker" class="headerlink" title="cloud9-docker"></a>cloud9-docker</h3><p><strong>(此方法已过期)</strong><br>Dockerfile的github地址在这里：<a href="https://github.com/kdelfour/cloud9-docker" target="_blank" rel="noopener">https://github.com/kdelfour/cloud9-docker</a></p><p>我们将它克隆下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir cloud9</span><br><span class="line">cd cloud9</span><br><span class="line">git clone https://github.com/kdelfour/cloud9-docker.git</span><br></pre></td></tr></table></figure><p>然后就要改改文件了，方法如下：</p><p>（我是参考别人的）</p><blockquote><p>参考issue页面<a href="https://github.com/kdelfour/cloud9-docker/issues/15" target="_blank" rel="noopener">https://github.com/kdelfour/cloud9-docker/issues/15</a><br>pbelyaev的回答:<br>Just clone this repository and edit conf/cloud9.conf:</p><p>[program:cloud9]<br>command = node /cloud9/server.js –listen 0.0.0.0 –port 80 –auth user:password -w /workspace<br>directory = /cloud9<br>user = root<br>autostart = true<br>autorestart = true<br>stdout_logfile = /var/log/supervisor/cloud9.log<br>stderr_logfile = /var/log/supervisor/cloud9_errors.log<br>environment = NODE_ENV=”production”<br>Then edit docker-compose.yml file:</p><p>…<br>  cnine:<br>    build: ./dir/to/cloned/repository</p></blockquote><p>改好以后就可以构建镜像了，build命令格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t image_name Dockerfile_path</span><br></pre></td></tr></table></figure></p><p>所以我们敲命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Dockerfile所在目录</span><br><span class="line">docker build -t yourname/cloud9 .</span><br></pre></td></tr></table></figure></p><p>构建完成后，我们来创建并启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p 80:80 -v /your-path/workspace/:/workspace/ yourname/cloud9 --auth user:password</span><br></pre></td></tr></table></figure><p><strong>注：记得将user:password改为你自己的用户名:密码；yourname/cloud9是你自己起的image名字。</strong></p><p><a href="http://your-server-ip" target="_blank" rel="noopener">http://your-server-ip</a></p><p>就可以进入icloud了。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐大家看我以前写的hexo系列：</p><p><a href="https://heliublog.com/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener">搭建hexo博客小记——hexo系列文章（一）</a></p><p><a href="https://heliublog.com/2016/05/14/Hexo%E5%88%A9%E7%94%A8Swiftype%E5%BB%BA%E7%AB%8B%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/" target="_blank" rel="noopener">利用Swiftype建立站内搜索——hexo系列文章（二）</a></p><p><a href="https://heliublog.com/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">VPS+Hexo+Dropbox创建个人博客——hexo系列教程（三）</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
            <tag> Hexo </tag>
            
            <tag> cloud9 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分享一些极好用的Chrome插件</title>
      <link href="/2017/05/10/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E6%9E%81%E5%A5%BD%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/05/10/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E6%9E%81%E5%A5%BD%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Bookmark-Search"><a href="#Bookmark-Search" class="headerlink" title="Bookmark Search"></a>Bookmark Search</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>你的Chrome书签是不是存了好多呢？当用到的时候却不知道放在那个目录了？哈哈哈，<br>现在有福了，我们可以借助Chrome插件”Bookmark Search”来解决这个棘手的问题，<br>有了它，我们就可以很方便的搜索以前存过的书签啦~~~！！！是不是很爽呢？</p><h3 id="插件效果"><a href="#插件效果" class="headerlink" title="插件效果"></a>插件效果</h3><p><img src="/uploads/1705101.jpg" alt="Bookmark Search 插件效果"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>只要在地址栏输入<code>bm</code>然后敲空格或<code>Tab</code>键就可以进入书签索引了，然后在地址栏里敲进你想<br>搜索的书签名就可以啦！</p><h2 id="start-me"><a href="#start-me" class="headerlink" title="start.me"></a>start.me</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><p>其实严格说来这个也不算是插件吧，就是个网页。但是也会有个辅助的插件。</p><h3 id="插件效果-1"><a href="#插件效果-1" class="headerlink" title="插件效果"></a>插件效果</h3><p>效果呢，就是在你打开一个新Chrome标签页后，显示的不是8个格子和一个大大的搜索框，而是一个网页，这个网页上显示了你所有的书签。<br><img src="/uploads/1705121.png" alt="start.me"></p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>打开一个新的标签页就可以使用啦！</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Dropbox备份vps中的文件</title>
      <link href="/2017/05/07/%E5%88%A9%E7%94%A8Dropbox%E5%A4%87%E4%BB%BDvps%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2017/05/07/%E5%88%A9%E7%94%A8Dropbox%E5%A4%87%E4%BB%BDvps%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>部分内容参考自<a href="http://www.pythoner.com/324.html" target="_blank" rel="noopener">http://www.pythoner.com/324.html</a></p></blockquote><h2 id="1-Linux-中安装Dropbox-Uploader"><a href="#1-Linux-中安装Dropbox-Uploader" class="headerlink" title="1.Linux 中安装Dropbox Uploader"></a>1.Linux 中安装Dropbox Uploader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.github.com/andreafabrizi/Dropbox-Uploader/master/dropbox_uploader.sh</span><br><span class="line">chmod+x dropbox_uploader.sh</span><br><span class="line">./dropbox_uploader.sh</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-新建Dropbox-App"><a href="#2-新建Dropbox-App" class="headerlink" title="2.新建Dropbox App"></a>2.新建Dropbox App</h2><ol><li><p>需要通过浏览器访问 <a href="https://www.dropbox.com/developers/apps" target="_blank" rel="noopener">https://www.dropbox.com/developers/apps</a> 页面，并创建一个新的 Dropbox app。（具体根据上一步中脚本的提示），”the type of access”根据自己的要求选择。</p></li><li><p>创建好后，将会进入一个新的页面，复制里面的<code>app key</code> 和 <code>app secret</code>到终端窗口。完成后，dropboxploader.sh 将产生一个oAUTH网址，进去授权就OK了。</p></li><li>现在就可以上传文件了。我此处是做的leanote备份，命令如下。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/public/upload/ /leanote/public/upload/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/files/ /leanote/files/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/conf/app.conf /leanote/conf/app.conf</span><br></pre></td></tr></table></figure><p>也可以做个脚本，定时运行</p><p>脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">cd /root/bin</span><br><span class="line">#开始上传</span><br><span class="line"></span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/public/upload/ /leanote/public/upload/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/files/ /leanote/files/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/conf/app.conf /leanote/conf/app.conf</span><br><span class="line"></span><br><span class="line">echo -e &quot;Backup Done!&quot;</span><br></pre></td></tr></table></figure><p>定时运行方法：（添加crontab）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab –e</span><br><span class="line">添加：</span><br><span class="line">30 3 * * * /root/bin/backup.sh</span><br><span class="line">这样，就可以每天凌晨3：30自动备份到Dropbox了。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Dropbox </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leanote安装教程</title>
      <link href="/2017/05/07/Leanote%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2017/05/07/Leanote%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此教程参考官方教程<a href="https://github.com/leanote/leanote/wiki/leanote%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">Leanote安装教程</a>而成，只是做了一点修改。</p></blockquote><h2 id="下载Leanote"><a href="#下载Leanote" class="headerlink" title="下载Leanote"></a>下载Leanote</h2><p>此处我下载的是二进制版，假设下载到<code>/home/wwwroot/blog.heleou.com/web/</code>下，那么下载后解压，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf leanote-*.tar.gz</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="安装数据库-mongodb"><a href="#安装数据库-mongodb" class="headerlink" title="安装数据库-mongodb"></a>安装数据库-mongodb</h2><p>到 <a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">http://www.mongodb.org/downloads</a> 去下载</p><p>64位linux mongodb2.6.4下载链接: <a href="http://www.mongodb.org/dr//fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.6.4.tgz/download" target="_blank" rel="noopener">http://www.mongodb.org/dr//fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.6.4.tgz/download</a><br>64位linux mongodb 3.0.1下载链接: <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz</a></p><p>我下载的是3.0.1版，这两个版本的拷贝数据库操作不太一样，到后面的时候需要稍微注意一下。</p><p>还是直接解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf mongodb-linux-x86_64-3.0.1.tgz/</span><br></pre></td></tr></table></figure></p><p>为了快速使用mongodb的命令, 可以配置环境变量,</p><p>编辑<code>/etc/profile</code> 将mongodb bin路径加入即可.（写到文件最后即可）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">export PATH=$PATH:/home/wwwroot/blog.heleou.com/web/mongodb/bin</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><h2 id="简单使用mongoDB"><a href="#简单使用mongoDB" class="headerlink" title="简单使用mongoDB"></a>简单使用mongoDB</h2><p>先在/home/wwwroot/blog.heleou.com/web下新建一个目录data存放mongodb数据</p><p>开启mongodb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath /home/wwwroot/blog.heleou.com/web/data</span><br></pre></td></tr></table></figure></p><p>附：后台开启命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --fork --dbpath /home/wwwroot/blog.heleou.com/web/data --logpath /home/wwwroot/blog.heleou.com/web/logpath1/mongodb.log</span><br></pre></td></tr></table></figure></p><p><code>--logpath</code>是日志路径，自己设置即可。</p><p>这时mongod已经启动了</p><p>重新打开一个终端, 使用下mongodb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mongo</span><br><span class="line">&gt; show dbs</span><br></pre></td></tr></table></figure><p>mongodb安装到此为止, 下面为mongodb导入数据leanote初始数据</p><h2 id="导入初始数据"><a href="#导入初始数据" class="headerlink" title="导入初始数据"></a>导入初始数据</h2><p>v3的导入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h localhost -d leanote --dir /home/wwwroot/blog.heleou.com/web/leanote/mongodb_backup/leanote_install_data/</span><br></pre></td></tr></table></figure></p><h2 id="配置leanote"><a href="#配置leanote" class="headerlink" title="配置leanote"></a>配置leanote</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/app.conf</span><br></pre></td></tr></table></figure><p>这里要做的有两件事，一个是修个URL，一个是修改安全信息。</p><ol><li>修改网址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.port=80</span><br><span class="line">site.url=http://blog.heleou.com</span><br></pre></td></tr></table></figure></li></ol><p>当然你还需要将a.com绑定ip到Leanote服务器.</p><p>如果服务器上已有其它程序运行了80端口, 怎么办呢? 请google或百度下 “使用nginx分发请求到不同端口”.</p><h2 id="运行leanote"><a href="#运行leanote" class="headerlink" title="运行leanote"></a>运行leanote</h2><p>注意 在此之前请确保mongodb已在运行!</p><p>新开一个窗口, 运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /home/wwwroot/blog.heleou.com/web/leanote/bin</span><br><span class="line">bash run.sh (或 sh run.sh)</span><br><span class="line"># 最后出现以下信息证明运行成功</span><br><span class="line">...</span><br><span class="line">TRACE 2013/06/06 15:01:27 watcher.go:72: Watching: /home/life/leanote/bin/src/github.com/leanote/leanote/conf/routes</span><br><span class="line">Go to /@tests to run the tests.</span><br><span class="line">Listening on :80...</span><br></pre></td></tr></table></figure><p>附：后台运行方法</p><p>此时按<code>Crtl + z</code>暂停进程，然后敲入<code>bg</code>命令即可，退出终端还可继续运行。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leanote </tag>
            
            <tag> VPS </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Swiftype建立站内搜索——hexo系列文章（二）</title>
      <link href="/2016/05/14/Hexo%E5%88%A9%E7%94%A8Swiftype%E5%BB%BA%E7%AB%8B%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"/>
      <url>/2016/05/14/Hexo%E5%88%A9%E7%94%A8Swiftype%E5%BB%BA%E7%AB%8B%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>部分内容引用自<a href="http://www.jianshu.com/p/2010ad07d960" target="_blank" rel="noopener">http://www.jianshu.com/p/2010ad07d960</a></p></blockquote><blockquote><p>原文链接：<a href="http://drunkevil.com/2015/04/08/swiftype-search-engine-for-hexo/" target="_blank" rel="noopener">http://drunkevil.com/2015/04/08/swiftype-search-engine-for-hexo/</a><br>作者：drunkevil</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此方法是基于jacman主题，其余主题可能稍有不同</p><h2 id="Swiftype账号注册及搜索引擎开通"><a href="#Swiftype账号注册及搜索引擎开通" class="headerlink" title="Swiftype账号注册及搜索引擎开通"></a>Swiftype账号注册及搜索引擎开通</h2><ul><li>进入<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype官网</a>注册账号，并根据提示初始化搜索引擎。</li><li>获得js代码，复制到jacman\layout\ _partial目录下的footer.ejs文件，在最后一个<code>&lt;/div&gt;</code>标签前即可。<a id="more"></a><h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2></li></ul><ol><li><p>在jacman主题下的_config.yml文件末尾添加如下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swift_search:</span><br><span class="line">     enable: true</span><br></pre></td></tr></table></figure></li><li><p>在hexo的source目录下建立一个search文件夹，并在其中新建一个index.md文件，其内容为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: search</span><br><span class="line">title: search</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>找到jacman\layout\ _partial目录下的header.ejs文件，在其中添加如下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.swift_search.enable)&#123; %&gt;</span><br><span class="line">   &lt;form class=&quot;search&quot; action=&quot;&lt;%- config.root %&gt;search/index.html&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt;</span><br><span class="line">   &lt;input type=&quot;text&quot; id=&quot;st-search-inpu&quot; maxlength=&quot;20&quot; placeholder=&quot;搜索&quot; /&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;% &#125;</span><br></pre></td></tr></table></figure></li><li><p>将jacman\layout\ _partial目录下的search.ejs中的内容替换为如下代码（主要用来控制结果的显示样式，可根据个人爱好修改）：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.swift_search.enable) &#123; %&gt;</span><br><span class="line">   &lt;div  id=&quot;container&quot; class=&quot;page&quot;&gt;</span><br><span class="line">     &lt;div id=&quot;st-results-container&quot; style=&quot;width:70%; margin:1.5em auto&quot;&gt;正在加载搜索结果，请稍等。&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.st-result-text &#123;</span><br><span class="line">background: #fafafa;</span><br><span class="line">display: block;</span><br><span class="line">border-left: 0.5em solid #ccc;</span><br><span class="line">-webkit-transition: border-left 0.45s;</span><br><span class="line">-moz-transition: border-left 0.45s;</span><br><span class="line">-o-transition: border-left 0.45s;</span><br><span class="line">-ms-transition: border-left 0.45s;</span><br><span class="line">transition: border-left 0.45s;</span><br><span class="line">padding: 0.5em;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123;</span><br><span class="line">.st-result-text &#123;</span><br><span class="line">padding: 1em;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">.st-result-text:hover &#123;</span><br><span class="line">     border-left: 0.5em solid #ea6753;</span><br><span class="line">   &#125;</span><br><span class="line">.st-result-text h3 a&#123;</span><br><span class="line">     color: #2ca6cb;</span><br><span class="line">     line-height: 1.5;</span><br><span class="line">     font-size: 22px;</span><br><span class="line">   &#125;</span><br><span class="line">.st-snippet em &#123;</span><br><span class="line">     font-weight: bold;</span><br><span class="line">     color: #ea6753;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>至此，配置完成，hexo d -g重新部署一下即可出现站内搜索功能。搜索框的样式可根据个人爱好在CSS文件中修改。</p><p>麻雀虽小，五脏俱全，博客的基础功能基本上都已实现。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Swiftype </tag>
            
            <tag> 站内搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win8.1与ubuntu双系统安装（硬盘安装）</title>
      <link href="/2016/05/13/win8.1%E4%B8%8Eubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%EF%BC%88%E7%A1%AC%E7%9B%98%E5%AE%89%E8%A3%85%EF%BC%89/"/>
      <url>/2016/05/13/win8.1%E4%B8%8Eubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%EF%BC%88%E7%A1%AC%E7%9B%98%E5%AE%89%E8%A3%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>部分内容引用自<a href="http://blog.csdn.net/risingwonderland/article/details/37902777" target="_blank" rel="noopener">http://blog.csdn.net/risingwonderland/article/details/37902777</a><br>作者：RisingWonderland</p></blockquote><h2 id="安装特点"><a href="#安装特点" class="headerlink" title="安装特点"></a>安装特点</h2><p>此方法可使用Win8.1,Ubuntu双系统，直接硬盘安装，无需制作U盘启动，很方便。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>下载Ubuntu镜像文件</li><li>下载EasyBCD<a id="more"></a><h2 id="第一步，磁盘分区"><a href="#第一步，磁盘分区" class="headerlink" title="第一步，磁盘分区"></a>第一步，磁盘分区</h2></li></ul><p>在Windows下，分割出一块分区，我分出来的是50G，建议在磁盘最后分。注意该分区不要增添盘符，而是让其保持“空闲”状态。</p><h2 id="第二步，NeoGrub"><a href="#第二步，NeoGrub" class="headerlink" title="第二步，NeoGrub"></a>第二步，NeoGrub</h2><p>Windows安装好EasyBCD软件，安好后，点击左侧“添加新条目”，再点击右侧“NeoGrub”选项卡，点击“安装”按钮。如下图：</p><p><img src="http://i.imgur.com/ygVfVWC.png" alt=""></p><p>安装后，点击“配置”按钮，会打开一个名为“menu.lst”的记事本文件。清空文件内容，写入下面的文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title Install Ububtu</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-14.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8</span><br><span class="line">initrd (hd0,0)/initrd.lz</span><br></pre></td></tr></table></figure></p><p>如下图所示，注意空格：</p><p><img src="http://i.imgur.com/6tqyUBh.png" alt=""></p><p></p><p style="color:#DD2D2D"><strong>注意1</strong></p>文件第2、3、4行出现的“(hd0,0)”指向的是当前系统盘的位置，我这里是C盘。但假如C盘并非首个分区，而是第二个，需要修改为“(hd0,1)”，依此类推。<p></p><p></p><p style="color:#DD2D2D"><strong>注意2</strong></p>文件第三行，“ubuntu-14.04-desktop-amd64.iso”是我的Ubuntu系统镜像的文件名，将其修改为你的。<p></p><p></p><p style="color:#DD2D2D"><strong>注意3</strong></p>文件第三行出现了“vmlinuz.efi”，由于我安装的Ubuntu是64位操作系统，此处必须是“vmlinuz.efi”，不能缺少扩展名。<p></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>使用压缩工具打开Ubuntu镜像文件，将“.disk”文件夹和casper文件夹内的“initrd.lz”和“vmlinuz.efi”文件复制到C盘根目录，再将Ubuntu系统镜像文件复制到C盘根目录：</p><p><img src="http://i.imgur.com/XVxEkBK.png" alt=""></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><ul><li>重启计算机，在启动界面看到操作系统选择项，选择“NeoGrub引导加载器”：<br><img src="http://o6hbo6ufa.bkt.clouddn.com/4.png" alt=""></li><li>之后出现Ubuntu选择界面，选择“Install Ubuntu”。</li><li>注意：此处有可能出现“File not found”错误，若出现，请转至原文博客查看：<a href="http://blog.csdn.net/risingwonderland/article/details/37902777" target="_blank" rel="noopener">http://blog.csdn.net/risingwonderland/article/details/37902777</a></li></ul><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>成功进入Ubuntu试用界面后，桌面上有两个文件。<br>按Ctrl+Alt+T打开终端，输入<code>sudo umount –l /isodevice</code>，取消光盘驱动器挂载，否则在后面安装过程中可能会无限卡进度：</p><p></p><p style="color:#DD2D2D"><strong>注意</strong></p>注意空格，而且“-l”中的“l”是大写字母“L”的小写形态。不是数字1，也不是字母“i”。<p></p><h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>双击桌面图标“安装Ubuntu14.04 LTS”，开始安装Ubuntu。<br>如果你连接了网络，可以选择“安装中下载更新”，会延长安装时间，也可以在安装完Ubuntu系统后再下载安装更新。<br>在“安装类型”界面会有多个安装选项：<br>如果选择第一项，Ubuntu会自动进行分区安装，之后与Windows操作系统共存为双系统。对分区没有细致要求的用户选择此项即可，本教程即可直接跳过步骤Step7、Step8。如果要自定义分区，选择“其它选项”。此处，我选择“其他选项”。<br><img src="http://o6hbo6ufa.bkt.clouddn.com/5.png" alt=""></p><p>我们要将Ubuntu安装在“空闲”分区内。选择“空闲”分区，再点击左下方红线处的加号，进行分区。</p><p>下面说一下我的分区状况：</p><p>总共50GB空闲分区，（分区时需要选择文件系统类型，选择“Ext4”即可）</p><ul><li>根目录“/”我分了8 GB；</li><li>交换分区swap我分了2 GB；（类似于虚拟内存）</li><li>/boot我分了200 MB；（引导分区）</li><li>/home 10 GB;（存放用户文件）</li><li>/usr 30GB;（存放应用程序）</li></ul><h2 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h2><p>分区完成后，开始安装。<br>如果你没有分配交换空间，系统会给出提示，跳过即可。</p><h2 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h2><p>安装完成后，选择重启。如果一切正常，可以看到如下图所示的Ubuntu样式的启动项选择界面：</p><p><img src="http://o6hbo6ufa.bkt.clouddn.com/6.png" alt=""></p><h2 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h2><p>在系统启动界面，Win8.1系统处于最后一项，如果需要让Win8.1处于第一项，可以这样设置：</p><ol><li>进入Ubuntu系统。</li><li>Ctrl+Alt+T打开终端，输入“sudo nautilus”，以root权限打开资源管理器。</li><li>找到“30_os-prober”文件，将其名称修改为“06_os-prober”即可：</li></ol><p>进入Windows系统，清除C盘下之前复制的文件。<br>打开EasyBCD，在之前的“添加新条目”功能中，点击“删除”按钮，清除“NeoGrub”引导。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPS服务器搭建ghost blog</title>
      <link href="/2016/05/01/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAghost%20blog/"/>
      <url>/2016/05/01/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAghost%20blog/</url>
      
        <content type="html"><![CDATA[<p>####前传</p><hr><p>&#160;&#160;无意中看到markdown语法，立马就喜欢上它，所以就想博客能不能也用这种语法写，因为我的博客原来一直用wordpress来搞，第一个想到的当然是用插件，当然也下到了，不过估计是主题css的问题，代码框老显示不出来，对于想要代码框的我来说实在是不能忍，就上网搜有没有其他的博客工具，哈哈终于找到了它，ghostblog！</p><p>&#160;&#160;但是安装下来着实费了不少功夫。总结起来比较简便的方法还是AMH+Node.js<br><a id="more"></a><br>注：以下步骤引用自：<br><a href="http://www.tuicool.com/articles/jQnIJf3" target="_blank" rel="noopener">http://www.tuicool.com/articles/jQnIJf3</a></p><ol><li><p>安装AMH，网上有详细教程</p></li><li><p>安装Node.js</p><p>也是网上的教程，不过有些gcc版本可能支持不了太新的Node.js</p></li><li><p>安装ghost</p><ol><li><p>新建数据库</p><p>登陆AMH面板，进入数据库，快速建库，很简单。</p></li><li><p>新建站点</p><p>登陆AMH面板，点击虚拟主机，新建虚拟主机，这也很简单。</p></li><li><p>安装Ghost程序</p><p>这里我们使用的是 <a href="http://ghostchina.com/" target="_blank" rel="noopener">http://ghostchina.com/</a> 发布的中文版Ghost。</p><p>登陆ssh，运行命令，</p><pre><code>wget http://dl.ghostchina.com/Ghost-0.5.9-zh-full.zip //下载Ghost到VPS  unzip Ghost-0.5.9-zh-full.zip -d ghost //解压Ghost-0.5.9-zh-full.zip并xiu修改文件夹名为ghost  </code></pre><p>如没有安装unzip，请执行 sudo yum install unzip 来安装，</p><p>&#160;&#160;到这里需要注意，ghost文件夹里的所有文件全部移动到之前你新建虚拟主机的web根目录下，不然会出错，文件移动号后，进入虚拟主机的web根目录下</p><pre><code>cd /虚拟主机web根目录路径   //进入虚拟主机web根目录，此步骤不能少  cp config.example.js config.js //复制config.example.js成config.js  vim config.js //用vim编辑config.js文件  </code></pre><p>将相关位置修改成以下这样：</p><pre><code>production: {  url: &apos;http://your_blog_url&apos;,mail: {},database: {client: &apos;mysql&apos;,connection: {host     : &apos;127.0.0.1&apos;, user     : &apos;root&apos;, //暂且直接用root账户password : &apos;password&apos;, //你的root账户密码database : &apos;ghost&apos;, //你之前建立的数据库名charset  : &apos;utf8&apos;},debug: false},server: {// Host to be passed to node&apos;s                 `net.Server#listen()`host: &apos;127.0.0.1&apos;,//改为0.0.0.0，否则他人无法访问// Port to be passed to node&apos;s `net.Server#listen()`, for iisnode set this to `process.env.PORT`port: &apos;2368&apos;}},</code></pre><p>这里说一下vim编辑器的一般用法：</p><p>i: 进入插入编辑模式</p><p>ESC: 退出编辑模式</p><p>:x : 退出并保存文件（退出编辑模式下使用）</p></li><li><p>配置Nginx</p><p>由于之前你新建的虚拟主机的Nginx配置是为php服务的，所以，我们要将其进行修改成为node.js服务，</p><pre><code>vim /usr/local/nginx/conf/***.conf //进入Nginx配置文件目录,并编辑与你新建的虚拟主机相应的Nginx配置文件  </code></pre><p>清空里面的内容，替换成以下：</p><pre><code>server {  listen 80;server_name  xxx.com www.xxxx.com; //替换为你自己的域名！location / {proxy_set_header   X-Real-IP $remote_addr;proxy_set_header   Host      $http_host;proxy_pass         http://127.0.0.1:2368; }}</code></pre><p>然后进AMH控制面板重启一下Nginx，</p><pre><code>npm start --production //启动Ghost，如果不出差错，在浏览器输入你的域名就可以看见Ghost的界面了，--production不能少  </code></pre><p>别以为到这就结束了，目前Ghost在我们SSH断开后就会结束进程，所以我们继续：</p></li><li><p>安装forever守护Ghost进程</p><p>为了让Ghost程序能够后台运行不中断，我们还得再安装个工具，就是forever，使用-g参数就是在全局模式中安装，这样我们就可以再任何地方都能使用forever命令了。</p><p>以下命令都请在网站根目录下运行</p><pre><code>npm install forever -g //forever的安装命令  NODE_ENV=production forever start index.js  //安装forever后的Ghost启动命令  </code></pre><p>   好了，Ghost就此安装完成</p></li></ol></li></ol><p>Ghost相关命令：</p><p>//以下命令都请在网站根目录下运行</p><pre><code>NODE_ENV=production forever start index.js //启动Ghost  NODE_ENV=production forever stop index.js //停止Ghost  NODE_ENV=production forever restart index.js //重启Ghost  </code></pre><p>现在，你就可以通过AMH控制面板进行数据管理、在线的文件编辑和上传 同样，你也可以按正常步骤新建一个php网站。</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ghost blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搭建hexo博客小记——hexo系列文章（一）</title>
      <link href="/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/"/>
      <url>/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要介绍在Github下搭建Hexo博客。总体说来，搭建Hexo总共需要两步：</p><ul><li>第一部分，部署本地博客，也就是在你的电脑上搭建起来Web环境；</li><li>第二部分，生成静态页面，并上传到Github上去。<a id="more"></a></li></ul><h2 id="搭建本地博客系统"><a href="#搭建本地博客系统" class="headerlink" title="搭建本地博客系统"></a>搭建本地博客系统</h2><p>搭建本地博客系统首先要部署环境，即Node.js和Git。</p><h3 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h3><p>可以<a href="https://nodejs.org/" target="_blank" rel="noopener">点此</a>下载nodejs，并按照步骤一步步安装；一切默认即可；</p><h3 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h3><p>git bash，<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">点此</a>下载即可。<br>部署好本地环境，便可以开始安装博客系统Hexo了</p><h3 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h3><p>Hexo可直接用<code>npm</code>安装，可在电脑任意文件夹下右键Git Bash Here，进去后，在命令行中输入</p><pre><code>npm install -g hexo</code></pre><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><pre><code>npm install</code></pre><h3 id="发布本地博客"><a href="#发布本地博客" class="headerlink" title="发布本地博客"></a>发布本地博客</h3><p>到上一步为止，本地博客已搭建完成，下面我们可以发布本地博客看看效果：（即生成静态页面）</p><pre><code>hexo generatehexo server</code></pre><p>当然，也可以用简写：</p><pre><code>hexo ghexo s</code></pre><p>本地服务器开启后，我们就可以进入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>浏览本地博客了。</p><h2 id="上传本地文件到Github"><a href="#上传本地文件到Github" class="headerlink" title="上传本地文件到Github"></a>上传本地文件到Github</h2><h3 id="申请账号并建立仓库。"><a href="#申请账号并建立仓库。" class="headerlink" title="申请账号并建立仓库。"></a>申请账号并建立仓库。</h3><p>账号自行申请，建立仓库即在页面右上角的+除新建一个<code>repository</code>。但是命名有要求，必须用你的用户名加上github.io来命名仓库名。比如你的用户名为user123，那么就命名为user123.github.io。</p><h3 id="获取SSH公钥，并与Github账号绑定。"><a href="#获取SSH公钥，并与Github账号绑定。" class="headerlink" title="获取SSH公钥，并与Github账号绑定。"></a>获取SSH公钥，并与Github账号绑定。</h3><h4 id="设置邮箱和用户名"><a href="#设置邮箱和用户名" class="headerlink" title="设置邮箱和用户名"></a>设置邮箱和用户名</h4><pre><code>git config --global user.email &quot;user123@gmail.com&quot; </code></pre><p>git config –global user.name “user123”</p><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><pre><code>ssh-keygen -t rsa -C &quot;user@gmail.com&quot;</code></pre><p>命令运行后，会在<code>C:\Users\你的计算机名\.ssh</code>中找到<code>id_rsa.pub</code>这个文件，貌似是pubication的文件，但是我用office打不开，所以不管它了，如果有老兄知道这个究竟是用什么打开比较好，可以在评论区告诉我。不过它也是可以用txt打开的，将其中的内容复制到以下位置：</p><p>先登录github，点击右上角你的账户头像，进入settings，进入SSH key选项卡，将<code>id_rsa.pub</code>中的所有内容添加进去即可。</p><h4 id="更改博客配置，为上传做准备。"><a href="#更改博客配置，为上传做准备。" class="headerlink" title="更改博客配置，为上传做准备。"></a>更改博客配置，为上传做准备。</h4><p>打开<code>D:\hexo</code>目录下的配置文件<code>_config.yml</code>（推荐用软件Sublime Text打开，不要用txt打开，因为这要UTF-8编码，而txt不会编码），翻到最下面，并改成以下内容，把<code>user123g</code>替换成你的用户名即可</p><pre><code>deploy:type: gitrepository: https://github.com/user123/user123.github.io.gitbranch: master</code></pre><p>注意：<code>type</code>后面一定要是<code>git</code>，不要填<code>Github</code>。这是最新版hexo的要求。还有就是上面配置文件的语法较为严格<code>type:</code>后面一定要留一个空格，<code>repository</code>，<code>branch</code>也一样。</p><h2 id="上传博客内容"><a href="#上传博客内容" class="headerlink" title="上传博客内容"></a>上传博客内容</h2><h3 id="先生成静态文件"><a href="#先生成静态文件" class="headerlink" title="先生成静态文件"></a>先生成静态文件</h3><pre><code>hexo g</code></pre><h3 id="部署前先输入以下命令，不然会出现error-deployer-not-found-github的报错。"><a href="#部署前先输入以下命令，不然会出现error-deployer-not-found-github的报错。" class="headerlink" title="部署前先输入以下命令，不然会出现error deployer not found:github的报错。"></a>部署前先输入以下命令，不然会出现<code>error deployer not found:github</code>的报错。</h3><pre><code>npm install hexo-deployer-git --save</code></pre><h3 id="上传文档（部署）"><a href="#上传文档（部署）" class="headerlink" title="上传文档（部署）"></a>上传文档（部署）</h3><pre><code>hexo d</code></pre><p>待出现<code>INFO Deploy done: git</code>即成功。成功后，进入网址<code>http://user123..github.io</code>浏览查看。</p><p>至此，所有工作都已完成，如果想更改主题什么的，可以看我后续的博客。有问题欢迎大家留言。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KeePass+KeePassHTTP+chromeIPass储存个人密码</title>
      <link href="/2016/05/01/KeePass/"/>
      <url>/2016/05/01/KeePass/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在密码越来越多，但是为了密码安全还是不愿所有网站用同一个密码。所以就想到了用密码管理软件。尝试过1Password和Lastpass，可惜都收费。所以找到了KeePass，不仅免费，还开源。支持多平台。结合插件，可以实现在chrome上自动填写密码。<br><a id="more"></a></p><blockquote><p>本文参考<a href="http://devzc.com/post/465" target="_blank" rel="noopener">http://devzc.com/post/465</a>写作而成，再次对原作者表示感谢。</p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>首先从以下网址下载所需文件</p><ul><li><p>KeePass主体程序:<br><a href="http://keepass.info/download.html" target="_blank" rel="noopener">http://keepass.info/download.html</a></p></li><li><p>KeePassHTTP扩展下载:<br><a href="https://github.com/pfn/keepasshttp/blob/master/KeePassHttp.plgx?raw=true" target="_blank" rel="noopener">https://github.com/pfn/keepasshttp/blob/master/KeePassHttp.plgx?raw=true</a><br>源码: <a href="https://github.com/pfn/keepasshttp/" target="_blank" rel="noopener">https://github.com/pfn/keepasshttp/</a></p></li><li><p>chromeIPass:<br>Chrome应用商店搜索[chromeIPass],安装即可;<br>chromeIPass源码: <a href="https://github.com/pfn/passifox" target="_blank" rel="noopener">https://github.com/pfn/passifox</a></p></li></ul></li><li><p>依次安装以上文件。<br>注意KeePassHTTP的配置：</p><ol><li>将KeePassHttp.plgx放在KeePass.exe同目录下,重启KeePass。并单击工具下的“KeePassHttp Options”。</li><li>按照如下图配置：<br><img src="http://i.imgur.com/0R82YzX.png" alt=""></li><li>点击Chrome上的chromeIPass图标，会出现Connect按钮,点击进去；</li><li>Key_Name自己起名</li><li><p>保存后，重新点击chromeIPass，若出现以下信息，则说明成功：</p><p><img src="http://i.imgur.com/PDcuXmf.png" alt=""></p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KeePass </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPS+Hexo+Dropbox创建个人博客——hexo系列教程（三）</title>
      <link href="/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考以下文章完成：<br>1.<a href="http://www.fanicy.com/2014/06/01/0001.hexowithvpsdropbox/" target="_blank" rel="noopener">用Hexo+Vps搭建博客并用Dropbox同步自动发布</a><br>2.<a href="http://www.jianshu.com/p/0839b09dc381#" target="_blank" rel="noopener">VPS+Dropbox+markeditor打造Hexo完美体验 (长期更新)</a><br>3.<a href="http://www.xmt.design/2016/04/04/blog-depoly-via-dropbox.html" target="_blank" rel="noopener">使用 Dropbox 和 VPS 实现实时部署 Hexo 博客</a></p></blockquote><p>废话少说，直接进入正题：</p><h2 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h2><p>为CentOS 6.8 x64 ,512MB内存</p><h2 id="安装需要的所有软件"><a href="#安装需要的所有软件" class="headerlink" title="安装需要的所有软件"></a>安装需要的所有软件</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git-core</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 前三步是先安装EPEL</span><br><span class="line"># wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm </span><br><span class="line"># wget http://rpms.famillecollet.com/enterprise/remi-release-6.rpm</span><br><span class="line"># rpm -Uvh remi-release-6*.rpm epel-release-6*.rpm</span><br><span class="line">% 安装node</span><br><span class="line">yum install nodejs npm --enablerepo=epel</span><br></pre></td></tr></table></figure><h3 id="安装Dropbox"><a href="#安装Dropbox" class="headerlink" title="安装Dropbox"></a>安装Dropbox</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd ~ &amp;&amp; wget -O - &quot;https://www.dropbox.com/download?plat=lnx.x86_64&quot; | tar xzf -</span><br><span class="line">%然后，从新建的 .dropbox-dist 文件夹运行 Dropbox 守护程序.</span><br><span class="line">~/.dropbox-dist/dropboxd</span><br><span class="line">%下载官方提供的 cli 来控制和管理Dropbox</span><br><span class="line">wget https://linux.dropbox.com/packages/dropbox.py</span><br><span class="line">%更改权限:</span><br><span class="line">chmod +x ./dropbox.py</span><br><span class="line">%启动Dropbox:</span><br><span class="line">./dropbox.py start y</span><br><span class="line">关闭局域网广播:</span><br><span class="line">./dropbox.py lansync n</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">cd Dropbox</span><br><span class="line">mkdir hexo</span><br><span class="line">cd hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>这里推荐不是很熟悉Nginx设置的用以下链接提供的一键安装包安装，可以只安装Nginx，自动设置<br><a href="https://blog.linuxeye.com/31.html" target="_blank" rel="noopener">lnmp、lamp、lnmpa一键安装包</a><br>这里设置时，可以将主机目录设置为dropbox的同步目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/Dropbox/hexo/public</span><br></pre></td></tr></table></figure></p><p>添加权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 /root/Dropbox/hexo/public</span><br><span class="line">chown www:www /root/Dropbox/hexo/public</span><br><span class="line">chmod +x /root/Dropbox/ /root/Dropbox/hexo/</span><br></pre></td></tr></table></figure></p><h3 id="安装incron"><a href="#安装incron" class="headerlink" title="安装incron"></a>安装incron</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install incron</span><br><span class="line">service incrond start</span><br></pre></td></tr></table></figure><h2 id="同步发布"><a href="#同步发布" class="headerlink" title="同步发布"></a>同步发布</h2><p>incron 监测文件夹配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrontab -e</span><br></pre></td></tr></table></figure></p><p>在其中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/root/Dropbox/hexo/source/_posts/ IN_MOVE,IN_MODIFY,IN_CREATE,IN_DELETE /root/runhexo.bash</span><br><span class="line">/root/Dropbox/hexo/theme/ IN_MOVE,IN_MODIFY,IN_CREATE,IN_DELETE /root/runhexo.bash</span><br></pre></td></tr></table></figure></p><p>runhexo.bash:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">exec 200&lt;$0</span><br><span class="line">flock -n 200 || exit 1</span><br><span class="line">sleep 10</span><br><span class="line">cd /root/Dropbox/hexo &amp;&amp; hexo g</span><br></pre></td></tr></table></figure></p><p>添加权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x runhexo.bash</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Hexo </tag>
            
            <tag> Dropbox </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

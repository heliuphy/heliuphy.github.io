<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>阮一峰JS学习笔记</title>
      <link href="/2018/10/14/%E9%98%AE%E4%B8%80%E5%B3%B0JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/14/%E9%98%AE%E4%B8%80%E5%B3%B0JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="阮一峰JS学习笔记"><a href="#阮一峰JS学习笔记" class="headerlink" title="阮一峰JS学习笔记"></a>阮一峰JS学习笔记</h1><h2 id="什么是JS"><a href="#什么是JS" class="headerlink" title="什么是JS"></a>什么是JS</h2><ol><li>它是脚本语言，即不具备开发操作系统的能力，而是只用来编写<strong>控制</strong>其他大型应用程序的”脚本“（比如浏览器）。</li><li>它是嵌入式语言，即没有IO，只能嵌入更大型得应用程序中，去调用宿主环境的IO。（浏览器、node）<h2 id="JS都包括什么"><a href="#JS都包括什么" class="headerlink" title="JS都包括什么"></a>JS都包括什么</h2>其核心语法相当精简，只包括两部分：</li></ol><ul><li>基本的语法构造<ul><li>操作符</li><li>控制结构</li><li>语句</li></ul></li><li>标准库</li></ul><p>除此之外，因为它要有宿主环境，所以就是一系列宿主环境的API。</p><h2 id="JS难在哪"><a href="#JS难在哪" class="headerlink" title="JS难在哪"></a>JS难在哪</h2><ul><li>它涉及大量的外部API</li><li>JS有不少设计缺陷，某些地方相当不合理。<h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><h3 id="语句and表达式"><a href="#语句and表达式" class="headerlink" title="语句and表达式"></a>语句and表达式</h3><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>指为了<strong>得到返回值的</strong>计算式。</p><p>两者的区别在于，语句一般是为了进行某种操作，改编程序运行状态，一般不需要返回值；而表达式是为了得到返回值，其一定会返回一个值。凡是JS中<strong>预期为一个值的</strong>地方，都可以放置表达式。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是对值旳<strong>具名引用</strong>。</p><h4 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h4><p>JS引擎的工作方式是：<strong>先</strong>解析代码，<strong>获取所有的被声明的变量</strong>，然后再一行一行的运行。这样也就是，所有变量声明的语句，都会被提升到代码头部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>真正运行的是如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>也就是用来识别各种值的合法名称。最常见的标识符就是<strong>变量名</strong>，以及<strong>函数名</strong>。</p><h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><p>对于<code>var</code>命令来说，<code>{ }</code>构成的区块不构成单独的作用域。</p><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><h4 id="switch结构"><a href="#switch结构" class="headerlink" title="switch结构"></a>switch结构</h4><p>多个<code>if--else</code>结构连在一起的时候，可使用更简单的<code>switch</code>结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"banana"</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"apple"</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>JS语言允许语句的前面有标签。相当于定位符。<br>通常与<code>break</code>和<code>continue</code>配合使用，跳出特定循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(...)&#123;</span><br><span class="line">            <span class="keyword">if</span>(...)&#123;</span><br><span class="line">                <span class="keyword">break</span> top;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接跳出外层循环，如果加标签，只默认跳出当前循环。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>数值：整数和小数</li><li>字符串</li><li>布尔值</li><li>undefined 未定义</li><li>null 空值</li><li>对象</li></ul><p>注：前三个成为”原始类型的值”，也就是不能再细分了。对象则是“合成类型”的值。至于那两个英文的，就是特殊值。</p><p>而至于<strong>对象</strong>，又可以分为三类：</p><ul><li>狭义的对象 object</li><li>数组 array</li><li>函数 function</li></ul><h4 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h4><p>这是<strong>运算符</strong>！</p><p>预告一下，JS共有三种方式可以确定一个值是什么类型的：</p><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li>Object.prototype.toString 方法</li></ul><h3 id="null-undefined-布尔"><a href="#null-undefined-布尔" class="headerlink" title="null, undefined, 布尔"></a>null, undefined, 布尔</h3><p>null表示值为空值，比如一个参数表示抛出的错误参数，如果此处无错，就会抛出<code>null</code>。</p><p>undefined表示未定义</p><p>关于布尔值，注意类型转换，空字符串转换为<code>false</code>而空数组和空对象则都是<code>true</code>。</p><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>注意，JS里的所有数字都是64位浮动点数存储。所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h4><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串转为整数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">//123</span></span><br></pre></td></tr></table></figure><h5 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h5><p>将字符串转换为浮点数。</p><h5 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h5><p>判断一个值是不是<code>NaN</code>。</p><h5 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h5><p>判断一个数值是不是一个正常的数值。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串可以像数组一样访问，但是不可以修改单个字符，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line"><span class="comment">//这样是改变不了的</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h4><ul><li>对象的所有键名都是字符串，所以是否加引号都可以。如果键名是数值，也会被自动转换成字符串。但是如果键名不符合明明规范，则必须加上引号，否则会报错。</li><li>键名又称为属性。它的值可以是任意类型，如果是函数，则这个属性又称为方法。</li><li>值如果是对象，则形成了链式引用。</li></ul><h4 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h4><p>如果不同变量名指向同一个变量，那么他们都是这个对象的引用，也就是指向相同的内存地址。改一个，其他的都会变。</p><p><strong>注意：</strong>这种引用仅限于对象，如果是<strong>原始类型的值</strong>的话，那么变量就是值的<strong>拷贝</strong>。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul><li>有两种运算符，一个是点运算符，另一个就是方括号运算符。</li><li>需要查看一个对象的所有属性，可以使用`Object.keys(yourObj)’方法。</li><li><p>属性的删除，使用<code>delete</code>命令。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.p</span><br></pre></td></tr></table></figure></li><li><p>要查看属性是否存在，可使用<code>in</code>运算符。即使是继承的属性，也会返回<code>true</code>。如果不需要继承，看下一条</p></li><li>判断自身属性，可使用<code>hasOwnProperty()</code>方法来判断。</li><li><p>怎么遍历对象的全部属性，可以使用<code>for...in...</code>循环。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> onj) &#123;</span><br><span class="line">    f(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意，会遍历继承的属性。但是必须是<strong>可遍历的对象</strong>。</p><p>  如果想遍历自身的属性，那么可以结合<code>hasOwnProperty()</code>方法判断一下。</p><h4 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(对象)&#123;</span><br><span class="line">    语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样提供的一种便利就是，在操作一个对象的多个属性时，会方便许多。</p><p>注意，<code>with</code>区块不会改变作用域，所以如果要给一个新属性赋值，需要先有这个属性才行。</p><p><strong>建议：</strong>不要使用<code>with</code>，可以使用一个临时变量来代替这种功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(obj1.obj2.obj3) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//可以写成</span></span><br><span class="line"><span class="keyword">var</span> temp = obj1.obj2.obj3;</span><br><span class="line"><span class="built_in">console</span>.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure></p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>三种方法</p><ol><li>function命令—函数的声明</li><li>函数表达式—变量赋值的写法，将匿名函数赋值给一个变量，这个匿名函数又叫<strong>函数表达式</strong>。</li><li>Function构造函数—几乎无人使用，不管了</li></ol><h4 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h4><p>函数在js中只是一种可以执行的值而已，与其他值无特殊之处。凡是可以使用值得地方，都可以使用函数。</p><h4 id="函数名得提升"><a href="#函数名得提升" class="headerlink" title="函数名得提升"></a>函数名得提升</h4><p>因为函数名就是变量名，所以使用<code>function</code>命里声明函数的时候，整个函数就会像变量声明一样，被提升到顶部。</p><h4 id="函数的属性"><a href="#函数的属性" class="headerlink" title="函数的属性"></a>函数的属性</h4><ul><li><p>name属性<br>  主要作用：获取作为参数得函数的名字。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) <span class="comment">//得到myFunc</span></span><br></pre></td></tr></table></figure></li><li><p>length属性<br>  返回函数预期传入的<strong>参数的个数</strong>，即函数定义中的参数个数。<br>  其作用可实现方法的<strong>重载</strong>。</p></li><li>toString()<br>  返回一个字符串，内容是函数的源码。<br>  其作用可以实现多行字符串。</li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在js中只有两种作用域，一个是<strong>全局作用域</strong>，另一个就是<strong>函数作用域</strong>。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><p>关于函数值得传递方式</p><ul><li>函数参数如果是原始类型得值，那么就<strong>按值传递</strong>。也就是说在函数体内修改参数值，不会影响到函数外部。    </li><li>如果函数参数是复合类型-（数组、对象、函数）的值，那么传递方式就是传址传递。</li><li><p>这里有一个小点需要注意一下就是，如果在函数体内部修改了整个参数的值，而不是某个属性。那么原对象的值是不会被修改的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = [<span class="number">1.</span> <span class="number">2.</span> <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    o = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这里，直接让参数o指向了另外一个对象，保存在原地址上的值当然不会受影响。</p><h4 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h4><p>只在函数体内部可以使用，这个对象包含了函数运行时的所有参数。<code>arguments[0]</code>是第一个参数。<br><code>arguments</code>对象含有一个<code>callee</code>属性返回它所对应的函数。</p><h4 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h4><ul><li>闭包：也就是能够读取其他函数内部变量的函数。<ul><li>小引例：因为js内层的函数可以读取外层函数的变量，而外层函数却能读取内部函数的变量，所以要想实现读取某个内部函数的变量可以通过下面这个函数实现  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">//99</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>这样就可以拐弯抹角的实现这个功能了。</code></pre><ul><li>闭包在这里就是这个函数<code>f2</code> , 他也就是将内部变量和外部变量相互链接的桥梁。<ul><li>闭包有两个作用<ul><li>一个是可以让外部函数访问内部函数的变量</li><li>第二就是可以让运行环境保存住函数内部的变量</li></ul></li><li>闭包还可以封装对象的私有属性和私有方法</li></ul></li><li>闭包会保留外层函数的内部变量，造成内存消耗，不能滥用。</li><li>立即调用的函数表达式<br>这里有一个很有意思的点，就是<code>function(){}</code>既可以当语句又可以当表达式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>所以为了能够区分，js引擎就认为<code>function</code>出现在行首就是一个语句。<br>但是加个括号阔起来就可以让引擎认为是一个表达式了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;...&#125;)();<span class="comment">//这样就可以直接调用函数了。</span></span><br></pre></td></tr></table></figure></p><p>为了避免污染全局变量，经常会直接调用匿名函数。</p><h4 id="eval命令"><a href="#eval命令" class="headerlink" title="eval命令"></a>eval命令</h4><p>eval接受一个字符串作为参数，并将这个字符串当做语句执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'var a = q'</span>);</span><br><span class="line">a <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p><p>会影响当前作用域的变量，不推荐使用。一般用来解析JSON但是JSON最好还是用<code>JSON.parse</code>方法。<br><strong>注意：</strong>只有<code>eval()</code>这一种形式属于直接调用，剩下的全属于别名调用，别名调用的<code>eval()</code>通通影响的事<strong>全局</strong>作用域。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tyoeof [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><p>可见数组的类型就是对象，那么数组有什么不同呢，数组的特殊性就体现在它的键名是按次序排列的一组整数<code>(0,1,2...)</code>。</p><p>但是读取的时候，对于数组的键名，不能使用点号读取。（因为数字开头不是合法的标识符）。</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li>length属性</li><li>in 运算符</li><li>for … in … 循环和数组遍历<ul><li>注意，这个不仅会遍历数组的数字键，还会遍历非数字键。</li><li>所以不推荐使用</li></ul></li><li>那么想简历数组最好使用<code>for</code>OR<code>while</code>循环。</li><li>数组的<code>forEach()</code>方法也能<strong>遍历数组</strong>。<h4 id="空位"><a href="#空位" class="headerlink" title="空位"></a>空位</h4>空位不同于<code>undefined</code>，遍历数组是，空位不会被遍历。<h4 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h4>只要有<code>length</code>属性，就可以认为是类似数组对象，但是它不是数组。要想将其转换为数组可以使用数组的<code>slice()</code>方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure><p>使用<code>call()</code>方法可以对类似数组的对象使用数组的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure><p>这样就可以让<code>arrayLike</code>使用<code>forEach</code>方法。</p><p>实际使用中最好还是先转成数组再使用。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li>注意强制类型转换Number()和parseInt的区别<ul><li>Number()函数比parseInt()函数要严格很多。基本上，只要有一个字符无法转成述职，整个字符串就是<code>NaN</code>。而，<code>parseInt()</code>却可以将前几个是数字的字符提取出来。</li></ul></li><li>自动转换的规则<ul><li>预期是什么类型的值，就调用该类型得转换函数。<h3 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h3><h4 id="Error构造函数"><a href="#Error构造函数" class="headerlink" title="Error构造函数"></a>Error构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错信息'</span>);</span><br><span class="line">err.message <span class="comment">// "出错信息"</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>此外还有几个派生的错误类</p><ul><li>SyntaxError</li><li>ReferenceError</li><li>RangeError</li><li>TypeError</li><li>URIError</li><li>EvalError</li><li>自定义错误类型（继承自Error）</li></ul><h4 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h4><p>作用是手动<strong>中断程序</strong>执行，抛出一个错误<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'x必须为正数'</span>); <span class="comment">//这里抛出一个错误对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="try…catch结构"><a href="#try…catch结构" class="headerlink" title="try…catch结构"></a>try…catch结构</h4><p>发生错误后可以对错误进行处理，捕捉错误，并决定是否执行下去。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error occured'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123; <span class="comment">// 这里的参数e就是捕获上面那个try返回的错误对象（这里为了产生错误，强行用了throw语句）</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.name + <span class="string">": "</span> + e.message);</span><br><span class="line">    <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h4><p><code>try...catch</code>后面还可以跟一个<code>finally</code>代码块，<strong>无论是否出现错误</strong>，都会执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanUp</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error occured'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'此行不会执行'</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'完成清理工作'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cleanUp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成清理工作</span></span><br><span class="line"><span class="comment">// Error: error occured</span></span><br></pre></td></tr></table></figure></p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><p>JS其他所有对象都是<strong>继承</strong>自<code>Object</code>对象，即都是<code>Object</code>的<strong>实例</strong>。</p><h4 id="原生方法"><a href="#原生方法" class="headerlink" title="原生方法"></a>原生方法</h4><ul><li><p>一类是<code>Object</code>本身的方法，</p><ul><li>即直接定义在Object对象上</li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123; <span class="built_in">console</span>.log(o)&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>还有一类就是<code>Object</code>的实例方法。</p><ul><li>即定义在Object原型对象<code>Object.prototype</code>上的方法。可以被Object实例直接使用。</li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.print()</span><br></pre></td></tr></table></figure></li><li><p>obj会直接继承 <code>Object.prototype</code> 上的方法.</p></li></ul></li></ul><h4 id="将Object-看为一个普通函数（工具函数）"><a href="#将Object-看为一个普通函数（工具函数）" class="headerlink" title="将Object()看为一个普通函数（工具函数）"></a>将Object()看为一个普通函数（工具函数）</h4><p>功能1：将任意值转换为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>功能2：判断某个变量是不是对象。因为Object有一个特点，就是当他的参数本身就是个对象的话，那么返回的还是原变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>(arr); <span class="comment">// 返回原数组</span></span><br><span class="line">obj === arr <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="当Object-是构造函数时"><a href="#当Object-是构造函数时" class="headerlink" title="当Object()是构造函数时"></a>当Object()是构造函数时</h4><p>即前面可以使用<code>new</code>命令。使用方法几乎等同于工具函数Object()，但是语义不一样。工具函数是指<strong>转换</strong>成对象。</p><h4 id="Object静态方法（即将Object看成一个普通的对象）"><a href="#Object静态方法（即将Object看成一个普通的对象）" class="headerlink" title="Object静态方法（即将Object看成一个普通的对象）"></a>Object静态方法（即将Object看成一个普通的对象）</h4><p>即部署在Object对象自身的方法。</p><h5 id="遍历对象的属性"><a href="#遍历对象的属性" class="headerlink" title="遍历对象的属性"></a>遍历对象的属性</h5><ul><li>Object.keys()</li><li>Object.getOwnPropertyNames()</li></ul><p>这两个的参数都是一个对象。区别在于，keys只返回可枚举的属性，而getOwnPropertyNames方法还可以返回补课枚举的属性。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>对象属性模型的相关方法</li><li>控制对象状态的方法</li><li>原型链相关方法</li></ul><h4 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h4><p>也就是定义在Object.prototype对象上的方法。所有Object的实例对象都继承了这些方法。</p><h5 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h5><p>返回一个对象的值，默认返回对象本身。其主要作用在于，自动类型转换时会<strong>调用</strong>。</p><h5 id="Obbject-prototype-toString"><a href="#Obbject-prototype-toString" class="headerlink" title="Obbject.prototype.toString()"></a>Obbject.prototype.toString()</h5><p>返回一个对象的字符串形式。默认返回<strong>类型</strong>字符串。也用于自动类型转换。可以得到想要的字符串形式。<br><strong>注意，</strong>这些函数有可能被用户重写，如果依然想调用，最好使用<code>Object.prototype.toString.call()</code>方法。<br>可以用于判断类型以及构造函数。这样会比<code>typeof</code>运算符更精确。</p><h5 id="Object-prototype-toLocalString"><a href="#Object-prototype-toLocalString" class="headerlink" title="Object.prototype.toLocalString()"></a>Object.prototype.toLocalString()</h5><p>与<code>toString</code>基本相同，也是返回字符串，但是可以加上一些用户的信息。比如返回日期的实例类型对象时，就和地域相关。</p><h5 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h5><p>返回一个布尔值，表示该实例对象自身是否具有该属性。</p><h3 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h3><p>是一种数据结构，用来描述某个属性是否可写、可遍历等。每个属性都有自己的属性描述对象。</p><h4 id="Object-getOwnPropertyDescription"><a href="#Object-getOwnPropertyDescription" class="headerlink" title="Object.getOwnPropertyDescription()"></a>Object.getOwnPropertyDescription()</h4><p>获取属性描述对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescription()</span><br></pre></td></tr></table></figure><h4 id="其他方法-1"><a href="#其他方法-1" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>Object.getOwnPropertyNames()</li><li>Object.defineProkperty()</li><li>Object.defineProperties()</li><li>Object.prototype.propertyIsEnumerable()</li></ul><h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p>也就是属性描述对象的属性</p><ul><li>value</li><li>writable</li><li>enumerable — 可以用来设置私密属性，只是不可以遍历到，但是还是可以访问的。如果要获取自身的所有属性（不管是否可遍历，都可以使用getOwnPropertyNames）</li><li>configurable – 是否可以修改属性描述对象</li><li><p>getter/setter – 存取器</p><p>  存取器有两种写法，一个是在键<code>get</code>和<code>set</code>的后面直接给出值。另一种是<code>get p() {}</code>和<code>set p(value) {}</code></p></li></ul><h4 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h4><p>这里要注意的是，怎么拷贝过来get()属性等。</p><h4 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h4><ul><li>Object.preventExtentions()</li><li>Object.isExtensible()</li><li>Object.seal()</li><li>Object.isSealed()</li><li>Object.freeze()</li><li>Object.isFrozen()</li></ul><h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h3><p><code>Array</code>是JS的原生<strong>对象</strong>，同时也是<strong>构造函数</strong>。</p><p>因为当Array构造函数的参数不同时，他的行为很不一致，所以最好直接使用数组字面量来创建新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad </span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//good </span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><h5 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h5><p>可以弥补<code>typeof</code>运算符的不足。</p><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li>valueOf()</li><li>toString()</li><li>push(), pop()</li><li>shift(), unshift()</li><li>join()—连接数组成员为字符串（可以自定义分隔符）</li><li>concat() —— 用于多个数组的合并</li><li>reverse()</li><li>slice() - arr.slice(start, end) –提取</li><li>splice() - arr.splice(start, end, addElem1, addElem2 ,….)删除，并且可以在删除的位置添加。返回值是被删除的元素。</li><li>sort()</li><li>map()</li><li>forEach()</li><li>filter()</li><li>some(), every()</li><li>reduce(), reduceRight()</li><li>indexOf(), lastIndexOf</li></ul><h3 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h3><p>就是将三种原始数据类型的值（数值、字符串、布尔值）包装为对象。</p><h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>可以从两个方面来理解：</p><ul><li>对象时<strong>单个实物</strong>的抽象。</li><li>对象是一个<strong>容器</strong>，封装了属性和方法。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>JS与C++不同，没有类的概念，也就是他不是基于类的，而是基于<strong>构造函数（constructor）</strong>和<strong>原型链（prototype）</strong>。JS使用构造函数作为对象的<strong>模板</strong>。一个构造函数，可以生成多个实例对象。</p><p>构造函数就是一个普通的函数，但是有自己的特征和用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了与普通函数区别，构造函数名字的第一个字母通常大写。</p><p>new命令：因为new命令本身就可以执行函数，不再需要函数的调用，所以可以不加括号执行，但是还是推荐加括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle;</span><br></pre></td></tr></table></figure><p>如果不使用<code>new</code>命令，而直接调用构造函数，会发生：构造函数变为普通函数，不会再生成实例对象，这里的<code>this</code>也将会代表全局对象。</p><h4 id="new命令执行过程"><a href="#new命令执行过程" class="headerlink" title="new命令执行过程"></a>new命令执行过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">constructor, plarams</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//将arguments对象转为数组</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//取出构造函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">constructor</span> = args.shift();</span><br><span class="line">    //创建一个空对象，继承构造函数的prototype属性</span><br><span class="line">    var context = Object.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line">    //执行构造函数</span><br><span class="line">    var result = <span class="keyword">constructor</span>.apply(context, args);</span><br><span class="line">    //如果返回结果是对象，就直接返回，否则返回context对象。</span><br><span class="line">    return (typeof result === 'object' &amp;&amp; result != null) ? result:context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例</span><br><span class="line">var actor = _new(Person, '张三', 28);</span><br></pre></td></tr></table></figure><h3 id="实例化对象的另一个方法Object-create"><a href="#实例化对象的另一个方法Object-create" class="headerlink" title="实例化对象的另一个方法Object.create()"></a>实例化对象的另一个方法Object.create()</h3><p>在拿不到构造函数，而只能拿到一个现有的对象的时候，我们可以以这个对象为模板，来生成新的实例对象。</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己构建Docker镜像在自己的服务器上搭建支持C++和tensorflow的jupyter-notebook</title>
      <link href="/2018/07/28/%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%94%AF%E6%8C%81C++%E5%92%8Ctensorflow%E7%9A%84jupyter-notebook/"/>
      <url>/2018/07/28/%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BADocker%E9%95%9C%E5%83%8F%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA%E6%94%AF%E6%8C%81C++%E5%92%8Ctensorflow%E7%9A%84jupyter-notebook/</url>
      <content type="html"><![CDATA[<h2 id="安装Docker软件"><a href="#安装Docker软件" class="headerlink" title="安装Docker软件"></a>安装Docker软件</h2><p>不再赘述，可参考本博客中以前的文章。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>github地址：</p><p><a href="https://github.com/heliuphy/myDockerRepo/blob/master/jupyter-cling/Dockerfile" target="_blank" rel="noopener">https://github.com/heliuphy/myDockerRepo/blob/master/jupyter-cling/Dockerfile</a></p><h2 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name jupyter-cling \</span><br><span class="line">-p 9002:8888 \</span><br><span class="line">--user root \</span><br><span class="line">-e GRANT_SUDO=yes \</span><br><span class="line">-e NB_UID=1001 \</span><br><span class="line">-e NB_GID=101 \</span><br><span class="line">-v /home/jupyter-cling:/home/jovyan/work \</span><br><span class="line">heliuphy/jupyter-cling start-notebook.sh \</span><br><span class="line">--NotebookApp.password=<span class="string">'sha1:********'</span></span><br><span class="line"><span class="comment"># -------------</span></span><br><span class="line"><span class="comment"># 增加 NB_UID 对目录的权限</span></span><br><span class="line">$ chown 1001 /home/jupyter-cling</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
            <tag> c++ </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>四步安装好支持tensorflow和C++的Jupyter-notebook</title>
      <link href="/2018/07/26/%E5%9B%9B%E6%AD%A5%E5%AE%89%E8%A3%85%E5%A5%BD%E6%94%AF%E6%8C%81tensorflow%E5%92%8CC++%E7%9A%84Jupyter-notebook/"/>
      <url>/2018/07/26/%E5%9B%9B%E6%AD%A5%E5%AE%89%E8%A3%85%E5%A5%BD%E6%94%AF%E6%8C%81tensorflow%E5%92%8CC++%E7%9A%84Jupyter-notebook/</url>
      <content type="html"><![CDATA[<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update <span class="comment"># Ubuntu</span></span><br><span class="line">sudo apt-get install docker</span><br></pre></td></tr></table></figure><h2 id="使用docker安装tensorflow-jupyter"><a href="#使用docker安装tensorflow-jupyter" class="headerlink" title="使用docker安装tensorflow-jupyter"></a>使用docker安装tensorflow-jupyter</h2><blockquote><p>参考网址        <a href="https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html" target="_blank" rel="noopener">https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name jupyter \</span><br><span class="line">-p 9001:8888 \</span><br><span class="line">--user root \</span><br><span class="line">-e GRANT_SUDO=yes \</span><br><span class="line">-e NB_UID=1000 \</span><br><span class="line">-e NB_GID=100 \</span><br><span class="line">-v /home/jupyter:/home/jovyan/work \</span><br><span class="line">jupyter/tensorflow-notebook start-notebook.sh \</span><br><span class="line">--NotebookApp.password=<span class="string">'sha1:********'</span></span><br></pre></td></tr></table></figure><p>参数解释：</p><p>\ 表示换行，把一条命令拆成多行以方便阅读<br>-d 表示启动的容器进入到后台运行；<br>-p 表示指定端口，这里把宿主机的 8888 端口映射到容器的 8888 端口；<br>–user=root，允许运行 sudo；<br>-e 指定 jovyan 用户相关权限 ID；<br>–name 表示给启动的容器设定名字;<br>-v 表示把宿主机的目录挂载到容器中。Jupyter Docker 的文档目录是 /home/jovyan/work，为了使得容器被销毁时，文档不受影响，将本地目录 /home/local/jupyter 挂载到 /home/jovyan/work;<br>-NotebookApp.password 是登录的密码，可以在 Ipython 中使用如下命令生成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> notebook.auth <span class="keyword">import</span> passwd</span><br><span class="line">In [<span class="number">2</span>]: passwd()</span><br><span class="line">Enter password: ****</span><br><span class="line">Verify password: ****</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">'sha1:********'</span></span><br></pre></td></tr></table></figure></p><h2 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h2><p>按照以上网址安装好后可以通过<a href="http://ip:9001访问自己的jupyter" target="_blank" rel="noopener">http://ip:9001访问自己的jupyter</a> notebook 。 但是带个端口号总是很别扭，所以这里通过Nginx来反向代理。<br>步骤如下：<br>通过 nginx -t 命令找到 Nginx 的配置文件地址。在 nginx.conf 文件中，新增如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">upstream notebook &#123;</span><br><span class="line">    server localhost:8888;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name yourdomain.com;</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass            http://notebook;</span><br><span class="line">    proxy_set_header      Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">location ~ /api/kernels/ &#123;</span><br><span class="line">    proxy_pass            http://notebook;</span><br><span class="line">    proxy_set_header      Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="comment"># websocket support</span></span><br><span class="line">    proxy_http_version    1.1;</span><br><span class="line">    proxy_set_header      Upgrade <span class="string">"websocket"</span>;</span><br><span class="line">    proxy_set_header      Connection <span class="string">"Upgrade"</span>;</span><br><span class="line">    proxy_read_timeout    86400;</span><br><span class="line">    &#125;</span><br><span class="line">location ~ /terminals/ &#123;</span><br><span class="line">    proxy_pass            http://notebook;</span><br><span class="line">    proxy_set_header      Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="comment"># websocket support</span></span><br><span class="line">    proxy_http_version    1.1;</span><br><span class="line">    proxy_set_header      Upgrade <span class="string">"websocket"</span>;</span><br><span class="line">    proxy_set_header      Connection <span class="string">"Upgrade"</span>;</span><br><span class="line">    proxy_read_timeout    86400;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 <code>nginx -s reload</code> ，重启 Nginx 服务后生效。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Jupyter 的基本单元是编程 cell 组成，也就是一个 <code>In[ ]</code>:</p><p>Jupyter 有三种类型的 cells：<code>code</code>，<code>markdown cells</code>，<code>raw cells</code>，常用的是 code cells 和 markdown cells 类型。</p><p>Cells 状态分为命令模式和编辑模式，Enter 进入编辑模式，ESC 进入命令模式，命令模式和编辑模式下支持很多操作快捷键。</p><p>常用命令模式快捷键：</p><ul><li>y: 单元进入代码状态</li><li>m: 转入markdown状态</li><li>r：转入raw状态</li><li>a: 上方插入新单元</li><li>b：下方插入新单元</li><li>x：剪切选中单元</li><li>c: 复制选中单元</li><li>shift-v：粘贴到上方单元</li></ul><h3 id="插入-Markdown"><a href="#插入-Markdown" class="headerlink" title="插入 Markdown"></a>插入 Markdown</h3><p>直接输入 Markdown ，然后 Run 即可渲染结果。支持标题，文本，视频，图片等。</p><h3 id="插入-LaTeX-公式"><a href="#插入-LaTeX-公式" class="headerlink" title="插入 LaTeX 公式"></a>插入 LaTeX 公式</h3><ul><li><p>创建行内公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$</span><br></pre></td></tr></table></figure></li><li><p>块级公式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ x = \dfrac&#123;-b \pm \sqrt&#123;b^2 - 4ac&#125;&#125;&#123;2a&#125; $$</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>可以直接在页面输出代码块，只需要在前后加上<code>代码块</code>即可。</p><h3 id="嵌入图片"><a href="#嵌入图片" class="headerlink" title="嵌入图片"></a>嵌入图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import Image</span><br><span class="line">Image(filename=&quot;yourpath.jpg&quot;)</span><br></pre></td></tr></table></figure><h3 id="嵌入音乐"><a href="#嵌入音乐" class="headerlink" title="嵌入音乐"></a>嵌入音乐</h3><p>可以嵌入本地音乐和网络音乐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import Audio</span><br><span class="line">Audio(filename=&quot;yourpath.wma&quot;)</span><br><span class="line">from IPython.display import Audio</span><br><span class="line">Audio(url=&quot;http://yourpath.wma&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="嵌入本地视频"><a href="#嵌入本地视频" class="headerlink" title="嵌入本地视频"></a>嵌入本地视频</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import io</span><br><span class="line">import base64</span><br><span class="line">from IPython.display import HTML</span><br><span class="line">video = io.open(&apos;/home/test.mp4&apos;, &apos;r+b&apos;).read()</span><br><span class="line">encoded = base64.b64encode(video)</span><br><span class="line">HTML(data=&apos;&apos;&apos;&lt;video alt=&quot;test&quot; controls&gt;</span><br><span class="line">     &lt;source src=&quot;data:video/mp4;base64,&#123;0&#125;&quot; type=&quot;video/mp4&quot; /&gt;</span><br><span class="line">     &lt;/video&gt;&apos;&apos;&apos;.format(encoded.decode(&apos;ascii&apos;)))</span><br></pre></td></tr></table></figure><h3 id="嵌入网页"><a href="#嵌入网页" class="headerlink" title="嵌入网页"></a>嵌入网页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import IFrame</span><br><span class="line">IFrame(&apos;http://yourpath.com&apos;, width=&apos;100%&apos;, height=350)</span><br></pre></td></tr></table></figure><h3 id="嵌入链接"><a href="#嵌入链接" class="headerlink" title="嵌入链接"></a>嵌入链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from IPython.display import FileLink</span><br><span class="line">FileLink(&apos;./test/a.ipynb&apos;)</span><br></pre></td></tr></table></figure><h3 id="魔法命令"><a href="#魔法命令" class="headerlink" title="魔法命令"></a>魔法命令</h3><p>所有以 <code>%</code> 开头的方法，都是所谓的魔术方法 (Magic function)，也就是 IPython 内置的一些方法。需要注意的是，魔术方法有%和 %% 之分，比如 <code>%timeit</code> 和 <code>%% timeit</code>。在 IPython 中有专门的叫法，前者叫 <code>line magic</code> 后者叫<code>cell magic</code>。顾名思义，前者是专门针对一行的命令，后者针对多行的命令。<br>通过 <code>%lsmagic</code>可以查看所有的 magic 命令，使用 <code>?</code> 或者 <code>??</code> 可以查看该命令的信息，后者可以查看源码。如： <code>%alias?</code>，会出现该方法的描述。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html" target="_blank" rel="noopener">https://www.chenshaowen.com/blog/interactive-notebook-jupyter.html</a><br><a href="https://github.com/jupyter/docker-stacks" target="_blank" rel="noopener">https://github.com/jupyter/docker-stacks</a><br><a href="http://www.cnblogs.com/giserliu/p/4997144.html" target="_blank" rel="noopener">http://www.cnblogs.com/giserliu/p/4997144.html</a></p><hr><h2 id="安装C-环境"><a href="#安装C-环境" class="headerlink" title="安装C++环境"></a>安装C++环境</h2><blockquote><p><a href="https://github.com/QuantStack/xeus-cling" target="_blank" rel="noopener">https://github.com/QuantStack/xeus-cling</a></p></blockquote><ul><li>安装<br>xeus-cling已经在linux和OS X平台上为conda包管理器打包。<br>为确保安装正常，最好安装xeus-cling在新的conda环境中。还需要使用miniconda安装，因为使用完整的anaconda，您可能会与zeromq已安装在anaconda发行版中的库发生冲突。<br>最安全的用法是创建一个以clingminiconda安装命名的环境</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -n cling</span><br><span class="line"><span class="built_in">source</span> activate cling</span><br></pre></td></tr></table></figure><p>然后，您可以在此环境xeus-cling及其依赖项中安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install xeus-cling notebook -c QuantStack -c conda-forge</span><br></pre></td></tr></table></figure></p><p>或者，如果已经安装了所有依赖项，则可以直接从源安装它。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX = your_conda_path -DCMAKE_INSTALL_LIBDIR = your_conda_path / lib</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><hr><h2 id="附：Jupyter-kernels"><a href="#附：Jupyter-kernels" class="headerlink" title="附：Jupyter-kernels"></a>附：Jupyter-kernels</h2><p><a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="noopener">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a></p>]]></content>
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> VPS </tag>
            
            <tag> python </tag>
            
            <tag> c++ </tag>
            
            <tag> jupyter-notebook </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HexoEditor 测试</title>
      <link href="/2018/07/20/HexoEditor-%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/07/20/HexoEditor-%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="从这里开始写"><a href="#从这里开始写" class="headerlink" title="从这里开始写"></a>从这里开始写</h2><p>提示：</p><ol><li>阅读更多标签：<a id="more"></a></li><li>代码记得写语言 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件推荐</title>
      <link href="/2017/06/19/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/2017/06/19/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这里归纳了一些提高工作效率的软件以及小工具。</p><a id="more"></a><h2 id="Typora–好用的Markdown编辑器"><a href="#Typora–好用的Markdown编辑器" class="headerlink" title="Typora–好用的Markdown编辑器"></a>Typora–好用的Markdown编辑器</h2><p>这是一款及其好用的Markdown编辑器，实时预览。可以打Latex公式。支持Mac、Windows、Linux，官网在<a href="https://www.typora.io/" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>将图片自动上传到七牛并在markdown中引用</title>
      <link href="/2017/05/16/%E5%B0%86%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E5%B9%B6%E5%9C%A8markdown%E4%B8%AD%E5%BC%95%E7%94%A8/"/>
      <url>/2017/05/16/%E5%B0%86%E5%9B%BE%E7%89%87%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E5%B9%B6%E5%9C%A8markdown%E4%B8%AD%E5%BC%95%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Markdown传统的插入图片的步骤实在是让人心累，所以我就上网搜了搜有没有啥简单的解决办法。倒是找到了不少支持自动上传到七牛云的Markdown编辑器，然而大多是只支持OSX,Win用户哭晕在厕所。。。。不过经过一番搜索，还是找到了不少顺手的工具。</p><p>这里推荐两种方式：</p><ol><li>Mpic软件，不管是拖拽上传、复制上传还是截图上传通通都支持，并且可以自动复制，官网地址：<a href="http://mpic.lzhaofu.cn/" target="_blank" rel="noopener">MPic-图床神器</a></li><li>可以借助一个工具，Github地址在这里：<a href="https://github.com/jiwenxing/qiniu-image-tool-win" target="_blank" rel="noopener">qiniu-image-tool-win</a></li></ol><p>这两种方式都可以，由于第一种很简单，这里只介绍第二种方式的配制方法。配置完后，使用起来体验也很好。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>从<a href="https://github.com/jiwenxing/qiniu-image-tool-win/releases" target="_blank" rel="noopener">release</a>页面下载成功后，解压。</li><li>安装AutoHotkey。<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2>编辑<code>qiniu-image-upload.ahk</code>文件，将一下内容做一些修改：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ACCESS_KEY = ***</span><br><span class="line">SECRET_KEY = ***</span><br><span class="line">BUCKET_NAME = ***  ;qiniu bucket name</span><br><span class="line">BUCKET_DOMAIN = http://7xry05.com1.z0.glb.clouddn.com/  ;qiniu domain for the image</span><br><span class="line">WORKING_DIR = E:\TOOLS\qiniu-image-tool-win\  ;directory that you put the qshell.exe</span><br></pre></td></tr></table></figure></li></ol><p>具体的内容请参考原作者博客，点<a href="http://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/" target="_blank" rel="noopener">这里</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装并配置成功后，只需两步即可插入图片到<code>markdown</code>文档中：</p><ol><li><code>Ctrl+c</code>复制图片</li><li><code>Ctrl+Alt+v</code>即可将<code>markdown</code>引用地址粘贴到文档中。<blockquote><p>参考：<a href="http://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/" target="_blank" rel="noopener">http://jverson.com/2016/08/30/autohotkey-markdown-uploadImage/</a><br><a href="https://github.com/jiwenxing/qiniu-image-tool-win" target="_blank" rel="noopener">https://github.com/jiwenxing/qiniu-image-tool-win</a></p></blockquote></li></ol>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 七牛云 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Bash编程（一）</title>
      <link href="/2017/05/15/Bash%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/05/15/Bash%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><p>shell是一个命令解释器，是介于操作系统内核与用户之间的一个绝缘层。准确地说，它也是能力很强的计算机语言，被称为解释性语言或脚本语言。它可以通过将<strong>系统调用、公共程序、工具和编译过的二进制程序</strong>“粘合”在一起来建立应用，这是大多数脚本语言的共同特征，所以有时候脚本语言又叫做“胶水语言”</p><a id="more"></a><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><code>&gt;</code> 这个符号是重定向,执行以下代码，就会在当前目录下生成一个my.txt。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> echo &quot;Hello World&quot; &gt; my.txt</span><br></pre></td></tr></table></figure></p><h3 id="小案例"><a href="#小案例" class="headerlink" title="小案例"></a>小案例</h3><p>如何利用bash将某文件的内容清楚而保留文件？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># 初始化一个变量</span><br><span class="line">LOG_DIR=/var/log</span><br><span class="line"></span><br><span class="line">cd $LOG_DIR</span><br><span class="line"></span><br><span class="line">cat /dev/null &gt; messages</span><br><span class="line">cat /dev/null &gt; wtmp</span><br><span class="line"></span><br><span class="line">echo &quot;Logs cleaned up.&quot;</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>注：<br><code>/dev/null</code> 这个东西可以理解为一个黑洞，里面是空的，将这个空文件写入某个文件，里面的内容就被删了。</p><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>行首以<code>#</code>开头(除<code>#!</code>之外)的是注释。<code>#!</code>是用于指定当前脚本的解释器，我们这里为<code>bash</code>，且应该指明完整路径，所以为<code>/bin/bash</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;The # here does not begin a comment.&quot;</span><br><span class="line">echo &apos;The # here does not begin a comment.&apos;</span><br><span class="line">echo The \# here does not begin a comment. # \#是转义字符</span><br><span class="line">echo The # 这里开始一个注释</span><br><span class="line">echo $(( 2#101011 ))     # 数制转换（使用二进制表示），不是一个注释，双括号表示对于数字的处理</span><br><span class="line"></span><br><span class="line"># 欢迎来到实验楼参观学习</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Bash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux零打碎敲</title>
      <link href="/2017/05/11/Linux%E9%9B%B6%E6%89%93%E7%A2%8E%E6%95%B2/"/>
      <url>/2017/05/11/Linux%E9%9B%B6%E6%89%93%E7%A2%8E%E6%95%B2/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>整理一些平时用到的Linux小东西，做积累。</p><a id="more"></a><h2 id="定时启动工具crond"><a href="#定时启动工具crond" class="headerlink" title="定时启动工具crond"></a>定时启动工具crond</h2><h3 id="先看看机子有没有启动crond"><a href="#先看看机子有没有启动crond" class="headerlink" title="先看看机子有没有启动crond"></a>先看看机子有没有启动crond</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond status</span><br></pre></td></tr></table></figure><p>如果没有安装crond，可以先安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装Crond</span></span><br><span class="line">yum install vixie-cron crontabs</span><br><span class="line"><span class="comment">#设置开机启动Crontab</span></span><br><span class="line">chkconfig crond on</span><br><span class="line"><span class="comment">#启动Crontab</span></span><br><span class="line">service crond start</span><br></pre></td></tr></table></figure></p><h3 id="添加定时任务"><a href="#添加定时任务" class="headerlink" title="添加定时任务"></a>添加定时任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><blockquote><p>以下引用自<a href="http://www.linuxidc.com/Linux/2010-08/27700.htm" target="_blank" rel="noopener">来源：Linux社区  作者：RedHat Linux中crond服务与crontab用法</a><br>crontab file的格式:<br>    crontab 文件中的行由 6 个字段组成，不同字段间用空格或 tab 键分隔。前 5 个字段指定命令要运行的时间<br>       分钟 (0-59)<br>       小时 (0-23)<br>       日期 (1-31)<br>       月份 (1-12)<br>       星期几（0-6，其中 0 代表星期日）<br>       第 6 个字段是一个要在适当时间执行的字符串<br>例子: </p></blockquote><pre><code>#MIN HOUR DAY MONTH DAYOFWEEK COMMAND #每天早上6点10分 10 6 * * * date #每两个小时 0 */2 * * * date    (solaris 5.8似乎不支持此种写法) #晚上11点到早上8点之间每两个小时，早上8点 0 23-7/2，8 * * * date #每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 0 11 4 * mon-wed date #1月份日早上4点 0 4 1 jan * date</code></pre><h3 id="重启crond"><a href="#重启crond" class="headerlink" title="重启crond"></a>重启crond</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond restart</span><br></pre></td></tr></table></figure><h2 id="查看磁盘空间大小"><a href="#查看磁盘空间大小" class="headerlink" title="查看磁盘空间大小"></a>查看磁盘空间大小</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -hl</span><br></pre></td></tr></table></figure><p>如下图<br><img src="http://op0n2nyjd.bkt.clouddn.com/1705111.JPG" alt="df -hl命令效果"></p><h2 id="sh文件格式"><a href="#sh文件格式" class="headerlink" title=".sh文件格式"></a>.sh文件格式</h2><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>文件的第一行必须是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br></pre></td></tr></table></figure></p><p>符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br>当编写脚本完成时，如果要执行该脚本，还必须使其可执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x filename</span><br></pre></td></tr></table></figure></p><p>用<code>./filename</code>来运行</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>以<code>#</code>开头的句子表示注释，直到这一行的结束。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VTK提示MetaImage cannot read data from file</title>
      <link href="/2017/05/10/VTK%E6%8F%90%E7%A4%BAMetaImage%20cannot%20read%20data%20from%20file/"/>
      <url>/2017/05/10/VTK%E6%8F%90%E7%A4%BAMetaImage%20cannot%20read%20data%20from%20file/</url>
      <content type="html"><![CDATA[<p>在运行《VTK图形图像进阶》第五章<code>5.3_ImageResliceExample.cpp</code>时，会提示<code>MetaImage cannot read data from file</code>或者显示窗口是空白，后来搜索了VTKExample中的例子，发现可以这样解决：<br><a id="more"></a><br>将原来程序中的语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgActor-&gt;SetInputData(colorMap-&gt;GetOutput());</span><br></pre></td></tr></table></figure></p><p>更改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgActor-&gt;GetMapper()-&gt;SetInputConnection(colorMap-&gt;GetOutputPort());</span><br></pre></td></tr></table></figure></p><p>记得在程序开头载入头文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vtkImageMapper3D.h&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>VTKExample:<a href="http://www.vtk.org/Wiki/VTK/Examples/Cxx/IO/MetaImageReader" target="_blank" rel="noopener">http://www.vtk.org/Wiki/VTK/Examples/Cxx/IO/MetaImageReader</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> VTK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo在线编写博客——hexo系列文章（四）</title>
      <link href="/2017/05/10/hexo%E5%9C%A8%E7%BA%BF%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
      <url>/2017/05/10/hexo%E5%9C%A8%E7%BA%BF%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这篇文章就是在线写出来的~</p><p>从编辑、到生成，全部云上完成，妈妈再也不用担心我在别的电脑上没法写hexo了！</p><a id="more"></a><p>效果如图：</p><p><img src="http://op0n2nyjd.bkt.clouddn.com//nextd/posts/img1705102.jpg" alt="cloud9在线写博客"></p><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>搭建这个环境其实也并不麻烦啦，Cloud9我是用别人的镜像装的，所以简单很多。总体来说，大概需要这些东西：</p><ul><li>VPS一台</li><li>Docker</li><li>Cloud9</li><li>nvm</li><li>node(建议&gt;6.*)</li><li>npm</li><li>hexo</li><li>apache(可选)</li><li>rsync(可选)</li><li>incrond（可选）</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="VPS篇"><a href="#VPS篇" class="headerlink" title="VPS篇"></a>VPS篇</h3><p>我VPS用的系统是CentOS6.8 x64</p><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>CentOS下安装Docker还是很简单的，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-io</span><br></pre></td></tr></table></figure></p><p>安装完后启动docker服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure></p><h3 id="Cloud9安装（Docker）"><a href="#Cloud9安装（Docker）" class="headerlink" title="Cloud9安装（Docker）"></a>Cloud9安装（Docker）</h3><h4 id="用VPS"><a href="#用VPS" class="headerlink" title="用VPS"></a>用VPS</h4><p><del><strong>注：</strong>dockerhub上现成的image是没有密码的，我可不希望别人谁都可以进来编辑我的博客，所以改一下Dockerfile，自己构建镜像。</del></p><p>不要用这个办法了，dockerhub上有现成的镜像<code>sapk/cloud9</code>，地址<a href="https://hub.docker.com/r/sapk/cloud9/" target="_blank" rel="noopener">点这里</a><br>想看旧方法，请<a href="https://heliublog.com/2017/05/10/hexo%E5%9C%A8%E7%BA%BF%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/#cloud9-docker" target="_blank" rel="noopener">点这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull sapk/cloud9</span><br><span class="line"></span><br><span class="line"># start with auth 将username,password替换成自己的账号密码</span><br><span class="line">docker run -d -v your-path/workspace:/workspace -p 8181:8181 sapk/cloud9 --auth username:password</span><br></pre></td></tr></table></figure><p><a href="http://ip:8181" target="_blank" rel="noopener">http://ip:8181</a>  查看效果吧！</p><h4 id="用Docker云"><a href="#用Docker云" class="headerlink" title="用Docker云"></a>用Docker云</h4><p>这里仅以<a href="https://arukas.io/" target="_blank" rel="noopener">Arukas</a>为例。<br>注册账号什么的就不说了。<br>直接创建应用，按照下图填写就行了：<br><img src="http://op0n2nyjd.bkt.clouddn.com//nextd/posts/img1705112.jpg" alt="Arukas"><br>创建完成后启动应用，如果一次不成功就多试几次。<br>创建成功后，点击<code>Endpoint</code>后面的链接就可以进到你自己的cloud9了。</p><p><strong>千万注意：我不知道这里的数据都储存在了哪里，所以一定要定时将自己的博文通过cloud9页面下载到自己的电脑上，以作备份。</strong></p><h3 id="nvm、node、npm、hexo"><a href="#nvm、node、npm、hexo" class="headerlink" title="nvm、node、npm、hexo"></a>nvm、node、npm、hexo</h3><p>这些我们一起讲，因为都是在cloud9中安装的。</p><h4 id="nvm、node、npm的安装"><a href="#nvm、node、npm的安装" class="headerlink" title="nvm、node、npm的安装"></a>nvm、node、npm的安装</h4><p>nvm是node的版本管理器。</p><h5 id="首先安装必要的包"><a href="#首先安装必要的包" class="headerlink" title="首先安装必要的包"></a>首先安装必要的包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update  </span><br><span class="line">sudo apt-get install build-essential libssl-dev</span><br></pre></td></tr></table></figure><p><strong>注意：cloud9镜像是用ubuntu搭建的，所以要用apt-get，这个不是centos系统了，不要弄混了~</strong></p><h5 id="安装nvm的脚本"><a href="#安装nvm的脚本" class="headerlink" title="安装nvm的脚本"></a>安装nvm的脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.4/install.sh | bash</span><br></pre></td></tr></table></figure><h5 id="使用nvm安装并使用node6"><a href="#使用nvm安装并使用node6" class="headerlink" title="使用nvm安装并使用node6"></a>使用nvm安装并使用node6</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm install v6.10.3</span><br><span class="line">nvm use v6.10.3</span><br><span class="line">node -v</span><br><span class="line"># v6.10.3  即表示安装成功</span><br></pre></td></tr></table></figure><p>npm有了，就不必装了</p><h4 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h4><blockquote><p>这个不是本文重点，可以参考我以前的文章<br><a href="https://heliublog.com/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener">搭建hexo博客小记——hexo系列文章（一）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">mkdir hexo</span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure></p></blockquote><p>好了，到此为止，整个在线环境就部署成功了，你可以<code>hexo d</code>来提交你的博客到github，当然，也可以用你的VPS来<br>做网页服务器。如果不想的话，下面的部分就不用看了。</p><hr><h3 id="apache安装"><a href="#apache安装" class="headerlink" title="apache安装"></a>apache安装</h3><p>由于我没学过前端，这里我用的是<a href="https://blog.linuxeye.com/31.html" target="_blank" rel="noopener">lnmp一键安装包</a>，可以只装Apache，别的都不用装。</p><p>将主机目录设置为<code>your-workspace/hexo/public</code></p><p>我的这样做是不行，改了权限也不行，所以只能用默认的目录<code>/data/wwwroot/your-domain-name</code>然后同步两个文件夹了。<br>这是就用到最后两个工具：</p><ul><li>rsync用来同步</li><li>incron用来监控文件改动</li></ul><h3 id="rsync的使用"><a href="#rsync的使用" class="headerlink" title="rsync的使用"></a>rsync的使用</h3><p>使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -av --delete /ressourcen /ressourcen_backup</span><br></pre></td></tr></table></figure></p><p>这样当<code>/ressourcen</code>目录中的文件有变动、删除时，就会同步到<code>/ressourcen_backup</code>。</p><p>我们要把这个文件写到一个脚本中，这样才能发挥他的作用（后述）。</p><h3 id="incron"><a href="#incron" class="headerlink" title="incron"></a>incron</h3><p>incron的使用，我在前面的文章中也提到过<a href="https://heliublog.com/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#安装incron" target="_blank" rel="noopener">VPS+Hexo+Dropbox创建个人博客</a></p><p>安装incron<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install incron</span><br><span class="line">service incrond start</span><br></pre></td></tr></table></figure></p><p>用incron来监测文件夹变动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">incrontab -e</span><br><span class="line"># 在其中添加：</span><br><span class="line">your-path/hexo/public IN_MOVE,IN_MODIFY,IN_CREATE,IN_DELETE your-path/runrsync.bash</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim runrsync.bash</span><br></pre></td></tr></table></figure><p>runrsync.bash中写入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">exec 200&lt;$0</span><br><span class="line">flock -n 200 || exit 1</span><br><span class="line">sleep 1</span><br><span class="line">rsync -av --delete /ressourcen /ressourcen_backup</span><br></pre></td></tr></table></figure></p><p>赋予权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x runrsync.bash</span><br></pre></td></tr></table></figure></p><p>这样当<code>hexo g</code>，<code>public</code>文件夹就会发生变动，此时incron检测到了文件变动，运行脚本<code>runrsync.bash</code>，实现两个文件夹的同步。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h3><p>若用国外主机，在<code>hexo new</code>时，会由于时区设置的问题，<code>date</code>显示的不是本地时间，可以更改时区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -R  # 查看当前系统时区</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 设置时区为东八区</span><br></pre></td></tr></table></figure></p><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><p>我们写了很多脚本，运行了很多服务，机器重启之后都不会开起来，所以我们要加入开机自启，才能保证功能的正常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.d/rc.local</span><br><span class="line"></span><br><span class="line"># 写入以下内容</span><br><span class="line"></span><br><span class="line"># Docker</span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line"># cloud9</span><br><span class="line">docker start 3e9a55a</span><br><span class="line"></span><br><span class="line"># incrond</span><br><span class="line">service incrond start</span><br></pre></td></tr></table></figure></p><h2 id="old"><a href="#old" class="headerlink" title="old"></a>old</h2><h3 id="cloud9-docker"><a href="#cloud9-docker" class="headerlink" title="cloud9-docker"></a>cloud9-docker</h3><p><strong>(此方法已过期)</strong><br>Dockerfile的github地址在这里：<a href="https://github.com/kdelfour/cloud9-docker" target="_blank" rel="noopener">https://github.com/kdelfour/cloud9-docker</a></p><p>我们将它克隆下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir cloud9</span><br><span class="line">cd cloud9</span><br><span class="line">git clone https://github.com/kdelfour/cloud9-docker.git</span><br></pre></td></tr></table></figure><p>然后就要改改文件了，方法如下：</p><p>（我是参考别人的）</p><blockquote><p>参考issue页面<a href="https://github.com/kdelfour/cloud9-docker/issues/15" target="_blank" rel="noopener">https://github.com/kdelfour/cloud9-docker/issues/15</a><br>pbelyaev的回答:<br>Just clone this repository and edit conf/cloud9.conf:</p><p>[program:cloud9]<br>command = node /cloud9/server.js –listen 0.0.0.0 –port 80 –auth user:password -w /workspace<br>directory = /cloud9<br>user = root<br>autostart = true<br>autorestart = true<br>stdout_logfile = /var/log/supervisor/cloud9.log<br>stderr_logfile = /var/log/supervisor/cloud9_errors.log<br>environment = NODE_ENV=”production”<br>Then edit docker-compose.yml file:</p><p>…<br>  cnine:<br>    build: ./dir/to/cloned/repository</p></blockquote><p>改好以后就可以构建镜像了，build命令格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t image_name Dockerfile_path</span><br></pre></td></tr></table></figure></p><p>所以我们敲命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Dockerfile所在目录</span><br><span class="line">docker build -t yourname/cloud9 .</span><br></pre></td></tr></table></figure></p><p>构建完成后，我们来创建并启动容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -p 80:80 -v /your-path/workspace/:/workspace/ yourname/cloud9 --auth user:password</span><br></pre></td></tr></table></figure><p><strong>注：记得将user:password改为你自己的用户名:密码；yourname/cloud9是你自己起的image名字。</strong></p><p><a href="http://your-server-ip" target="_blank" rel="noopener">http://your-server-ip</a></p><p>就可以进入icloud了。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐大家看我以前写的hexo系列：</p><p><a href="https://heliublog.com/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/" target="_blank" rel="noopener">搭建hexo博客小记——hexo系列文章（一）</a></p><p><a href="https://heliublog.com/2016/05/14/Hexo%E5%88%A9%E7%94%A8Swiftype%E5%BB%BA%E7%AB%8B%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/" target="_blank" rel="noopener">利用Swiftype建立站内搜索——hexo系列文章（二）</a></p><p><a href="https://heliublog.com/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">VPS+Hexo+Dropbox创建个人博客——hexo系列教程（三）</a></p>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Hexo </tag>
            
            <tag> VPS </tag>
            
            <tag> cloud9 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分享一些极好用的Chrome插件</title>
      <link href="/2017/05/10/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E6%9E%81%E5%A5%BD%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6/"/>
      <url>/2017/05/10/%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%BE%E6%9E%81%E5%A5%BD%E7%94%A8%E7%9A%84Chrome%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="Bookmark-Search"><a href="#Bookmark-Search" class="headerlink" title="Bookmark Search"></a>Bookmark Search</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>你的Chrome书签是不是存了好多呢？当用到的时候却不知道放在那个目录了？哈哈哈，<br>现在有福了，我们可以借助Chrome插件”Bookmark Search”来解决这个棘手的问题，<br>有了它，我们就可以很方便的搜索以前存过的书签啦~~~！！！是不是很爽呢？</p><h3 id="插件效果"><a href="#插件效果" class="headerlink" title="插件效果"></a>插件效果</h3><p><img src="/uploads/1705101.jpg" alt="Bookmark Search 插件效果"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>只要在地址栏输入<code>bm</code>然后敲空格或<code>Tab</code>键就可以进入书签索引了，然后在地址栏里敲进你想<br>搜索的书签名就可以啦！</p><h2 id="start-me"><a href="#start-me" class="headerlink" title="start.me"></a>start.me</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><p>其实严格说来这个也不算是插件吧，就是个网页。但是也会有个辅助的插件。</p><h3 id="插件效果-1"><a href="#插件效果-1" class="headerlink" title="插件效果"></a>插件效果</h3><p>效果呢，就是在你打开一个新Chrome标签页后，显示的不是8个格子和一个大大的搜索框，而是一个网页，这个网页上显示了你所有的书签。<br><img src="/uploads/1705121.png" alt="start.me"></p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>打开一个新的标签页就可以使用啦！</p>]]></content>
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vtk-imageblend图像融合报错</title>
      <link href="/2017/05/07/vtk-imageblend%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E6%8A%A5%E9%94%99/"/>
      <url>/2017/05/07/vtk-imageblend%E5%9B%BE%E5%83%8F%E8%9E%8D%E5%90%88%E6%8A%A5%E9%94%99/</url>
      <content type="html"><![CDATA[<blockquote><p>参考：<a href="http://blog.csdn.net/u012526003/article/details/52066403" target="_blank" rel="noopener">http://blog.csdn.net/u012526003/article/details/52066403</a></p></blockquote><p>在运行《VTK图像开发进阶》中<code>5.2_ImageBlendExample.cpp</code>代码时，报错<code>vtkCompositeDataPipeline (004A4880): Input for connection on index 0 input port index 1 for algorithm vtkImageBlend(004A1958) is of type vtkImageData, but a vtkImageStencilData is required.</code>正在无解之际，找到了解决办法，感谢原博主。<br>只需将原程序中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageBlend-&gt;SetInput(0,reader-&gt;GetOutput());</span><br><span class="line">imageBlend-&gt;SetInput(1,imageSource-&gt;GetOutput());</span><br></pre></td></tr></table></figure></p><p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageBlend-&gt;AddInputData(reader-&gt;GetOutput());</span><br><span class="line">imageBlend-&gt;AddInputData(imageSource-&gt;GetOutput());</span><br></pre></td></tr></table></figure></p><p>即可。</p>]]></content>
      
      <categories>
          
          <category> VTK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VTK-5.10.1 to VTK-7.1.1的变动</title>
      <link href="/2017/05/07/VTK-5.10.1%20TO%20VTK-7.1.1%E7%9A%84%E5%8F%98%E5%8A%A8/"/>
      <url>/2017/05/07/VTK-5.10.1%20TO%20VTK-7.1.1%E7%9A%84%E5%8F%98%E5%8A%A8/</url>
      <content type="html"><![CDATA[<ol><li>namespace vtkstd ==&gt;&gt; std；</li><li>SetInput()方法拆分为两个，一个SetInputData，一个SetInputConnection()。</li><li>vtk的新版本在vtkImageData类中取消了SetScalarTypeToUnsignedChar()方法；(vtkImageCanvasSource2D类中依然可用)现在仅能用如下方法设置：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void SetScalarType(int, vtkInformation* meta_data);</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a>]]></content>
      
      <categories>
          
          <category> VTK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VTK运行Tcl文件</title>
      <link href="/2017/05/07/VTK%E8%BF%90%E8%A1%8CTcl%E6%96%87%E4%BB%B6/"/>
      <url>/2017/05/07/VTK%E8%BF%90%E8%A1%8CTcl%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>环境：</p><ul><li>Win10 64bit 家庭版</li><li>VS-2008</li><li>VTK-7.1.1</li><li>Tcl-8.6</li></ul><ol><li>下载ActiveTcl，可以去activestate网站下载。下载完成后安装，例如安装路径是d:\tcl  <strong>注意：安装时一定要以管理员身份运行，不然会加不进系统变量！</strong></li></ol><a id="more"></a><ol start="2"><li>打开CMAKE，Configure完成后，将<code>VTK_WRAP_TCL</code>勾选上，再次Configure，之后将<code>TCL_INTERNAL_PATH</code>更改为<code>\你的VTK源码解压路径\VTK-7.1.1\ThirdParty\TclTk\internals\tk8.6</code><br><strong>注意：切记:要用“/”而不是“\”。</strong></li><li>打开生成文件夹，使用VTK.SLN生成，之后在INSTALL方案上选“仅用于项目”-&gt;“仅生成INSTALL”安装。</li><li>在PATH中添加：D:\Tcl\bin;D:\VTK\bin;新建系统变量<code>TCLLIBPATH</code>，内容设为<code>\你的VTK生成文件夹\VTK-7.1.1-bin\Wrapping\Tcl\Debug</code><br>完成。<br>遇到的坑：</li><li>安装Tcl时，未按照管理员身份运行，导致Tcl没有加进系统变量。</li><li>未设置<code>TCL_INTERNAL_PATH</code>，因为这个的参数默认是错的。<br>这两条导致编译VTK.sln时，有80多个项目编译失败。</li><li>由于<code>TCLLIBPATH</code>的设置错误，导致打开Tcl文件时提示<code>can&#39;t find package vtk</code>。</li></ol><blockquote><p>参考：<a href="http://www.cnblogs.com/limeng/archive/2010/08/28/1810701.html" target="_blank" rel="noopener">http://www.cnblogs.com/limeng/archive/2010/08/28/1810701.html</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> VTK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTK </tag>
            
            <tag> Tcl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VTK-VS2008编译教程</title>
      <link href="/2017/05/07/VTK-VS2008%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/"/>
      <url>/2017/05/07/VTK-VS2008%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Win10 64bit 家庭版</li><li>VS2008 SP1</li><li>Qt 4.8.4</li><li>CMake 3.8.0 64bit-win</li><li>VTK-7.1.1</li></ul><a id="more"></a><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>将上述组件下载安装好<br>注意事项：</p><ol><li>Qt需要下载两个东西：<ul><li>qt-win-opensource-4.8.4-vs2008.exe</li><li>qt-vs-addin-1.1.11-opensource.exe<br>直接谷歌搜索文件名即可找到下载地址。</li></ul></li><li>VTK-7.1.1可以下载data也可以不下载。<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h3>按照提示一步步安装即可<h3 id="安装-CMAKE"><a href="#安装-CMAKE" class="headerlink" title="安装 CMAKE"></a>安装 CMAKE</h3>下载后安装即可<h3 id="编译VTK"><a href="#编译VTK" class="headerlink" title="编译VTK"></a>编译VTK</h3></li><li>新建两个文件夹，一个src，用来存放源代码；一个bin，用来存放二进制文件。</li><li>将VTK-7.1.1.zip解压至src。</li><li>打开CMAKE，<code>Where is the source code</code> 填写src的绝对路径，<code>Where to build the binaries</code> 填写bin的绝对路径，比那一成功后的文件就放在这里。</li><li>点击Config，选择VS2008，确定后，开始编译，过程大约几分钟。</li><li>待编译完成后，会出现许多红色的选项，这些都是需要修改的选项。勾选CMake界面上的Grouped和Advanced, Grouped是对配置分组,Advanced是显示高级配置.</li><li>VTK_Group_Qt          选中,使用Qt.</li><li>CMAKE_INSTALL_PREFIX  修改为VTK/vsvtk  。这个目录可以自行指定,当VTK编译完成后,安装时,会将VTK安装到指定的目录。</li><li>INSTALL_BIN_DIR<br>INSTALL_INC_DIR<br>INSTALL_LIB_DIR<br>INSTALL_MAN_DIR<br>INSTALL_PKGCONFIG_DIR<br>这些也分别更改到VTK\vsvtk 的相应目录下。</li><li>configuer</li><li>generate</li><li>完成后，打开VTK\bin 用VS打开构建目录下的VTK.sln解决方案。</li><li>等待IDE解析,解析完成后,状态栏会显示就绪.解析过程比较耗时,耐心等待VS解析完成。</li><li>生成成功之后,就可以安装VTK了,右击INSTALL项目,选择仅生成INSTALL.然后就开始安装VTK了,安装完成,就可以在之前设置的prefix目录下看到安装之后的VTK.</li><li>设置环境变量，将VTK\vsvtk 加入环境变量。<h2 id="案例运行"><a href="#案例运行" class="headerlink" title="案例运行"></a>案例运行</h2>新建文件夹Example，在文件夹下新建src和bin。<br>进入网址<a href="http://www.vtk.org/Wiki/VTK/Examples/Cxx/Rendering/Cylinder" target="_blank" rel="noopener">http://www.vtk.org/Wiki/VTK/Examples/Cxx/Rendering/Cylinder</a><br>复制源代码。<br>若VTK_DIR not found ，则手动填写为VTL\bin。<br>configure,generate。<br>用VS打开工程并编译。<br>打开cmd，进入所在目录，运行*.exe即可。</li></ol>]]></content>
      
      <categories>
          
          <category> VTK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VTK </tag>
            
            <tag> visualstudio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何利用Dropbox备份指定文件夹</title>
      <link href="/2017/05/07/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Dropbox%E5%A4%87%E4%BB%BD%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>/2017/05/07/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Dropbox%E5%A4%87%E4%BB%BD%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      <content type="html"><![CDATA[<p>Dropbox原生只带同步单文件夹的功能，但如果我想同步其他的文件夹怎么办呢？不能把那些文件夹都复制一份到该目录下吧。所以可用<code>mklink</code>的方法来同步。(Win Vista 及以上可用)</p><p>命令如下，比如我的Dropbox备份文件夹为<code>C:\Dropbox</code>，而我想备份的文件夹为<code>d:\backup</code>，注意必须用管理员模式运行cmd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink /d &quot;C:\Dropbox\your-name&quot; D:\backup</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dropbox </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Dropbox备份vps中的文件</title>
      <link href="/2017/05/07/%E5%88%A9%E7%94%A8Dropbox%E5%A4%87%E4%BB%BDvps%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2017/05/07/%E5%88%A9%E7%94%A8Dropbox%E5%A4%87%E4%BB%BDvps%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<blockquote><p>部分内容参考自<a href="http://www.pythoner.com/324.html" target="_blank" rel="noopener">http://www.pythoner.com/324.html</a></p></blockquote><h2 id="1-Linux-中安装Dropbox-Uploader"><a href="#1-Linux-中安装Dropbox-Uploader" class="headerlink" title="1.Linux 中安装Dropbox Uploader"></a>1.Linux 中安装Dropbox Uploader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.github.com/andreafabrizi/Dropbox-Uploader/master/dropbox_uploader.sh</span><br><span class="line">chmod+x dropbox_uploader.sh</span><br><span class="line">./dropbox_uploader.sh</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-新建Dropbox-App"><a href="#2-新建Dropbox-App" class="headerlink" title="2.新建Dropbox App"></a>2.新建Dropbox App</h2><ol><li><p>需要通过浏览器访问 <a href="https://www.dropbox.com/developers/apps" target="_blank" rel="noopener">https://www.dropbox.com/developers/apps</a> 页面，并创建一个新的 Dropbox app。（具体根据上一步中脚本的提示），”the type of access”根据自己的要求选择。</p></li><li><p>创建好后，将会进入一个新的页面，复制里面的<code>app key</code> 和 <code>app secret</code>到终端窗口。完成后，dropboxploader.sh 将产生一个oAUTH网址，进去授权就OK了。</p></li><li>现在就可以上传文件了。我此处是做的leanote备份，命令如下。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/public/upload/ /leanote/public/upload/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/files/ /leanote/files/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/conf/app.conf /leanote/conf/app.conf</span><br></pre></td></tr></table></figure><p>也可以做个脚本，定时运行</p><p>脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">cd /root/bin</span><br><span class="line">#开始上传</span><br><span class="line"></span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/public/upload/ /leanote/public/upload/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/files/ /leanote/files/</span><br><span class="line">./dropbox_uploader.sh upload /home/wwwroot/blog.heleou.com/web/leanote/conf/app.conf /leanote/conf/app.conf</span><br><span class="line"></span><br><span class="line">echo -e &quot;Backup Done!&quot;</span><br></pre></td></tr></table></figure><p>定时运行方法：（添加crontab）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab –e</span><br><span class="line">添加：</span><br><span class="line">30 3 * * * /root/bin/backup.sh</span><br><span class="line">这样，就可以每天凌晨3：30自动备份到Dropbox了。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPS </tag>
            
            <tag> Dropbox </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leanote安装教程</title>
      <link href="/2017/05/07/Leanote%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
      <url>/2017/05/07/Leanote%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<blockquote><p>此教程参考官方教程<a href="https://github.com/leanote/leanote/wiki/leanote%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">Leanote安装教程</a>而成，只是做了一点修改。</p></blockquote><h2 id="下载Leanote"><a href="#下载Leanote" class="headerlink" title="下载Leanote"></a>下载Leanote</h2><p>此处我下载的是二进制版，假设下载到<code>/home/wwwroot/blog.heleou.com/web/</code>下，那么下载后解压，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf leanote-*.tar.gz</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="安装数据库-mongodb"><a href="#安装数据库-mongodb" class="headerlink" title="安装数据库-mongodb"></a>安装数据库-mongodb</h2><p>到 <a href="http://www.mongodb.org/downloads" target="_blank" rel="noopener">http://www.mongodb.org/downloads</a> 去下载</p><p>64位linux mongodb2.6.4下载链接: <a href="http://www.mongodb.org/dr//fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.6.4.tgz/download" target="_blank" rel="noopener">http://www.mongodb.org/dr//fastdl.mongodb.org/linux/mongodb-linux-x86_64-2.6.4.tgz/download</a><br>64位linux mongodb 3.0.1下载链接: <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.1.tgz</a></p><p>我下载的是3.0.1版，这两个版本的拷贝数据库操作不太一样，到后面的时候需要稍微注意一下。</p><p>还是直接解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf mongodb-linux-x86_64-3.0.1.tgz/</span><br></pre></td></tr></table></figure></p><p>为了快速使用mongodb的命令, 可以配置环境变量,</p><p>编辑<code>/etc/profile</code> 将mongodb bin路径加入即可.（写到文件最后即可）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line">export PATH=$PATH:/home/wwwroot/blog.heleou.com/web/mongodb/bin</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><h2 id="简单使用mongoDB"><a href="#简单使用mongoDB" class="headerlink" title="简单使用mongoDB"></a>简单使用mongoDB</h2><p>先在/home/wwwroot/blog.heleou.com/web下新建一个目录data存放mongodb数据</p><p>开启mongodb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --dbpath /home/wwwroot/blog.heleou.com/web/data</span><br></pre></td></tr></table></figure></p><p>附：后台开启命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --fork --dbpath /home/wwwroot/blog.heleou.com/web/data --logpath /home/wwwroot/blog.heleou.com/web/logpath1/mongodb.log</span><br></pre></td></tr></table></figure></p><p><code>--logpath</code>是日志路径，自己设置即可。</p><p>这时mongod已经启动了</p><p>重新打开一个终端, 使用下mongodb</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; mongo</span><br><span class="line">&gt; show dbs</span><br></pre></td></tr></table></figure><p>mongodb安装到此为止, 下面为mongodb导入数据leanote初始数据</p><h2 id="导入初始数据"><a href="#导入初始数据" class="headerlink" title="导入初始数据"></a>导入初始数据</h2><p>v3的导入命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -h localhost -d leanote --dir /home/wwwroot/blog.heleou.com/web/leanote/mongodb_backup/leanote_install_data/</span><br></pre></td></tr></table></figure></p><h2 id="配置leanote"><a href="#配置leanote" class="headerlink" title="配置leanote"></a>配置leanote</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/app.conf</span><br></pre></td></tr></table></figure><p>这里要做的有两件事，一个是修个URL，一个是修改安全信息。</p><ol><li>修改网址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.port=80</span><br><span class="line">site.url=http://blog.heleou.com</span><br></pre></td></tr></table></figure></li></ol><p>当然你还需要将a.com绑定ip到Leanote服务器.</p><p>如果服务器上已有其它程序运行了80端口, 怎么办呢? 请google或百度下 “使用nginx分发请求到不同端口”.</p><h2 id="运行leanote"><a href="#运行leanote" class="headerlink" title="运行leanote"></a>运行leanote</h2><p>注意 在此之前请确保mongodb已在运行!</p><p>新开一个窗口, 运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /home/wwwroot/blog.heleou.com/web/leanote/bin</span><br><span class="line">bash run.sh (或 sh run.sh)</span><br><span class="line"># 最后出现以下信息证明运行成功</span><br><span class="line">...</span><br><span class="line">TRACE 2013/06/06 15:01:27 watcher.go:72: Watching: /home/life/leanote/bin/src/github.com/leanote/leanote/conf/routes</span><br><span class="line">Go to /@tests to run the tests.</span><br><span class="line">Listening on :80...</span><br></pre></td></tr></table></figure><p>附：后台运行方法</p><p>此时按<code>Crtl + z</code>暂停进程，然后敲入<code>bg</code>命令即可，退出终端还可继续运行。</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leanote </tag>
            
            <tag> VPS </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Swiftype建立站内搜索——hexo系列文章（二）</title>
      <link href="/2016/05/14/Hexo%E5%88%A9%E7%94%A8Swiftype%E5%BB%BA%E7%AB%8B%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"/>
      <url>/2016/05/14/Hexo%E5%88%A9%E7%94%A8Swiftype%E5%BB%BA%E7%AB%8B%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>部分内容引用自<a href="http://www.jianshu.com/p/2010ad07d960" target="_blank" rel="noopener">http://www.jianshu.com/p/2010ad07d960</a></p></blockquote><blockquote><p>原文链接：<a href="http://drunkevil.com/2015/04/08/swiftype-search-engine-for-hexo/" target="_blank" rel="noopener">http://drunkevil.com/2015/04/08/swiftype-search-engine-for-hexo/</a><br>作者：drunkevil</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此方法是基于jacman主题，其余主题可能稍有不同</p><h2 id="Swiftype账号注册及搜索引擎开通"><a href="#Swiftype账号注册及搜索引擎开通" class="headerlink" title="Swiftype账号注册及搜索引擎开通"></a>Swiftype账号注册及搜索引擎开通</h2><ul><li>进入<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype官网</a>注册账号，并根据提示初始化搜索引擎。</li><li>获得js代码，复制到jacman\layout\ _partial目录下的footer.ejs文件，在最后一个<code>&lt;/div&gt;</code>标签前即可。<a id="more"></a><h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2></li></ul><ol><li><p>在jacman主题下的_config.yml文件末尾添加如下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swift_search:</span><br><span class="line">     enable: true</span><br></pre></td></tr></table></figure></li><li><p>在hexo的source目录下建立一个search文件夹，并在其中新建一个index.md文件，其内容为：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout: search</span><br><span class="line">title: search</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>找到jacman\layout\ _partial目录下的header.ejs文件，在其中添加如下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.swift_search.enable)&#123; %&gt;</span><br><span class="line">   &lt;form class=&quot;search&quot; action=&quot;&lt;%- config.root %&gt;search/index.html&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt;</span><br><span class="line">   &lt;input type=&quot;text&quot; id=&quot;st-search-inpu&quot; maxlength=&quot;20&quot; placeholder=&quot;搜索&quot; /&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;% &#125;</span><br></pre></td></tr></table></figure></li><li><p>将jacman\layout\ _partial目录下的search.ejs中的内容替换为如下代码（主要用来控制结果的显示样式，可根据个人爱好修改）：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.swift_search.enable) &#123; %&gt;</span><br><span class="line">   &lt;div  id=&quot;container&quot; class=&quot;page&quot;&gt;</span><br><span class="line">     &lt;div id=&quot;st-results-container&quot; style=&quot;width:70%; margin:1.5em auto&quot;&gt;正在加载搜索结果，请稍等。&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.st-result-text &#123;</span><br><span class="line">background: #fafafa;</span><br><span class="line">display: block;</span><br><span class="line">border-left: 0.5em solid #ccc;</span><br><span class="line">-webkit-transition: border-left 0.45s;</span><br><span class="line">-moz-transition: border-left 0.45s;</span><br><span class="line">-o-transition: border-left 0.45s;</span><br><span class="line">-ms-transition: border-left 0.45s;</span><br><span class="line">transition: border-left 0.45s;</span><br><span class="line">padding: 0.5em;</span><br><span class="line">&#125;</span><br><span class="line">@media only screen and (min-width: 768px) &#123;</span><br><span class="line">.st-result-text &#123;</span><br><span class="line">padding: 1em;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">.st-result-text:hover &#123;</span><br><span class="line">     border-left: 0.5em solid #ea6753;</span><br><span class="line">   &#125;</span><br><span class="line">.st-result-text h3 a&#123;</span><br><span class="line">     color: #2ca6cb;</span><br><span class="line">     line-height: 1.5;</span><br><span class="line">     font-size: 22px;</span><br><span class="line">   &#125;</span><br><span class="line">.st-snippet em &#123;</span><br><span class="line">     font-weight: bold;</span><br><span class="line">     color: #ea6753;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>至此，配置完成，hexo d -g重新部署一下即可出现站内搜索功能。搜索框的样式可根据个人爱好在CSS文件中修改。</p><p>麻雀虽小，五脏俱全，博客的基础功能基本上都已实现。</p>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Swiftype </tag>
            
            <tag> 站内搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>win8.1与ubuntu双系统安装（硬盘安装）</title>
      <link href="/2016/05/13/win8.1%E4%B8%8Eubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%EF%BC%88%E7%A1%AC%E7%9B%98%E5%AE%89%E8%A3%85%EF%BC%89/"/>
      <url>/2016/05/13/win8.1%E4%B8%8Eubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%EF%BC%88%E7%A1%AC%E7%9B%98%E5%AE%89%E8%A3%85%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>部分内容引用自<a href="http://blog.csdn.net/risingwonderland/article/details/37902777" target="_blank" rel="noopener">http://blog.csdn.net/risingwonderland/article/details/37902777</a><br>作者：RisingWonderland</p></blockquote><h2 id="安装特点"><a href="#安装特点" class="headerlink" title="安装特点"></a>安装特点</h2><p>此方法可使用Win8.1,Ubuntu双系统，直接硬盘安装，无需制作U盘启动，很方便。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>下载Ubuntu镜像文件</li><li>下载EasyBCD<a id="more"></a><h2 id="第一步，磁盘分区"><a href="#第一步，磁盘分区" class="headerlink" title="第一步，磁盘分区"></a>第一步，磁盘分区</h2></li></ul><p>在Windows下，分割出一块分区，我分出来的是50G，建议在磁盘最后分。注意该分区不要增添盘符，而是让其保持“空闲”状态。</p><h2 id="第二步，NeoGrub"><a href="#第二步，NeoGrub" class="headerlink" title="第二步，NeoGrub"></a>第二步，NeoGrub</h2><p>Windows安装好EasyBCD软件，安好后，点击左侧“添加新条目”，再点击右侧“NeoGrub”选项卡，点击“安装”按钮。如下图：</p><p><img src="http://i.imgur.com/ygVfVWC.png" alt=""></p><p>安装后，点击“配置”按钮，会打开一个名为“menu.lst”的记事本文件。清空文件内容，写入下面的文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title Install Ububtu</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel (hd0,0)/vmlinuz.efi boot=casper iso-scan/filename=/ubuntu-14.04-desktop-amd64.iso ro quiet splash locale=zh_CN.UTF-8</span><br><span class="line">initrd (hd0,0)/initrd.lz</span><br></pre></td></tr></table></figure></p><p>如下图所示，注意空格：</p><p><img src="http://i.imgur.com/6tqyUBh.png" alt=""></p><p></p><p style="color:#DD2D2D"><strong>注意1</strong></p>文件第2、3、4行出现的“(hd0,0)”指向的是当前系统盘的位置，我这里是C盘。但假如C盘并非首个分区，而是第二个，需要修改为“(hd0,1)”，依此类推。<p></p><p></p><p style="color:#DD2D2D"><strong>注意2</strong></p>文件第三行，“ubuntu-14.04-desktop-amd64.iso”是我的Ubuntu系统镜像的文件名，将其修改为你的。<p></p><p></p><p style="color:#DD2D2D"><strong>注意3</strong></p>文件第三行出现了“vmlinuz.efi”，由于我安装的Ubuntu是64位操作系统，此处必须是“vmlinuz.efi”，不能缺少扩展名。<p></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>使用压缩工具打开Ubuntu镜像文件，将“.disk”文件夹和casper文件夹内的“initrd.lz”和“vmlinuz.efi”文件复制到C盘根目录，再将Ubuntu系统镜像文件复制到C盘根目录：</p><p><img src="http://i.imgur.com/XVxEkBK.png" alt=""></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><ul><li>重启计算机，在启动界面看到操作系统选择项，选择“NeoGrub引导加载器”：<br><img src="http://o6hbo6ufa.bkt.clouddn.com/4.png" alt=""></li><li>之后出现Ubuntu选择界面，选择“Install Ubuntu”。</li><li>注意：此处有可能出现“File not found”错误，若出现，请转至原文博客查看：<a href="http://blog.csdn.net/risingwonderland/article/details/37902777" target="_blank" rel="noopener">http://blog.csdn.net/risingwonderland/article/details/37902777</a></li></ul><h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p>成功进入Ubuntu试用界面后，桌面上有两个文件。<br>按Ctrl+Alt+T打开终端，输入<code>sudo umount –l /isodevice</code>，取消光盘驱动器挂载，否则在后面安装过程中可能会无限卡进度：</p><p></p><p style="color:#DD2D2D"><strong>注意</strong></p>注意空格，而且“-l”中的“l”是大写字母“L”的小写形态。不是数字1，也不是字母“i”。<p></p><h2 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h2><p>双击桌面图标“安装Ubuntu14.04 LTS”，开始安装Ubuntu。<br>如果你连接了网络，可以选择“安装中下载更新”，会延长安装时间，也可以在安装完Ubuntu系统后再下载安装更新。<br>在“安装类型”界面会有多个安装选项：<br>如果选择第一项，Ubuntu会自动进行分区安装，之后与Windows操作系统共存为双系统。对分区没有细致要求的用户选择此项即可，本教程即可直接跳过步骤Step7、Step8。如果要自定义分区，选择“其它选项”。此处，我选择“其他选项”。<br><img src="http://o6hbo6ufa.bkt.clouddn.com/5.png" alt=""></p><p>我们要将Ubuntu安装在“空闲”分区内。选择“空闲”分区，再点击左下方红线处的加号，进行分区。</p><p>下面说一下我的分区状况：</p><p>总共50GB空闲分区，（分区时需要选择文件系统类型，选择“Ext4”即可）</p><ul><li>根目录“/”我分了8 GB；</li><li>交换分区swap我分了2 GB；（类似于虚拟内存）</li><li>/boot我分了200 MB；（引导分区）</li><li>/home 10 GB;（存放用户文件）</li><li>/usr 30GB;（存放应用程序）</li></ul><h2 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h2><p>分区完成后，开始安装。<br>如果你没有分配交换空间，系统会给出提示，跳过即可。</p><h2 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h2><p>安装完成后，选择重启。如果一切正常，可以看到如下图所示的Ubuntu样式的启动项选择界面：</p><p><img src="http://o6hbo6ufa.bkt.clouddn.com/6.png" alt=""></p><h2 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h2><p>在系统启动界面，Win8.1系统处于最后一项，如果需要让Win8.1处于第一项，可以这样设置：</p><ol><li>进入Ubuntu系统。</li><li>Ctrl+Alt+T打开终端，输入“sudo nautilus”，以root权限打开资源管理器。</li><li>找到“30_os-prober”文件，将其名称修改为“06_os-prober”即可：</li></ol><p>进入Windows系统，清除C盘下之前复制的文件。<br>打开EasyBCD，在之前的“添加新条目”功能中，点击“删除”按钮，清除“NeoGrub”引导。</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 系统安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>beamer的theme</title>
      <link href="/2016/05/10/beamer%E7%9A%84theme/"/>
      <url>/2016/05/10/beamer%E7%9A%84theme/</url>
      <content type="html"><![CDATA[<p>发现两个不错的网站</p><ul><li><p>所有自带的主题列表</p><pre><code>https://www.hartwork.org/beamer-theme-matrix/</code></pre></li><li><p>这个网站也有不少好主题</p><p><a href="https://latex.simon04.net/" target="_blank" rel="noopener">https://latex.simon04.net/</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> latex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Endnote的style</title>
      <link href="/2016/05/01/Endnote%E7%9A%84style/"/>
      <url>/2016/05/01/Endnote%E7%9A%84style/</url>
      <content type="html"><![CDATA[<p>参考文献style:</p><p>Chinese Std GBT7714</p><ul><li><p>附上 <a href="https://my.pcloud.com/publink/show?code=XZlVCQZLKN5QnRFiPX6zm1oYzf9CfrRdCKk" target="_blank" rel="noopener">下载地址</a></p></li><li><p>安装方法：</p><ul><li>拷到…/style  文件夹下即可。</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Endnote </tag>
            
            <tag> style </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPS服务器搭建ghost blog</title>
      <link href="/2016/05/01/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAghost%20blog/"/>
      <url>/2016/05/01/VPS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAghost%20blog/</url>
      <content type="html"><![CDATA[<p>####前传</p><hr><p>&#160;&#160;无意中看到markdown语法，立马就喜欢上它，所以就想博客能不能也用这种语法写，因为我的博客原来一直用wordpress来搞，第一个想到的当然是用插件，当然也下到了，不过估计是主题css的问题，代码框老显示不出来，对于想要代码框的我来说实在是不能忍，就上网搜有没有其他的博客工具，哈哈终于找到了它，ghostblog！</p><p>&#160;&#160;但是安装下来着实费了不少功夫。总结起来比较简便的方法还是AMH+Node.js<br><a id="more"></a><br>注：以下步骤引用自：<br><a href="http://www.tuicool.com/articles/jQnIJf3" target="_blank" rel="noopener">http://www.tuicool.com/articles/jQnIJf3</a></p><ol><li><p>安装AMH，网上有详细教程</p></li><li><p>安装Node.js</p><p>也是网上的教程，不过有些gcc版本可能支持不了太新的Node.js</p></li><li><p>安装ghost</p><ol><li><p>新建数据库</p><p>登陆AMH面板，进入数据库，快速建库，很简单。</p></li><li><p>新建站点</p><p>登陆AMH面板，点击虚拟主机，新建虚拟主机，这也很简单。</p></li><li><p>安装Ghost程序</p><p>这里我们使用的是 <a href="http://ghostchina.com/" target="_blank" rel="noopener">http://ghostchina.com/</a> 发布的中文版Ghost。</p><p>登陆ssh，运行命令，</p><pre><code>wget http://dl.ghostchina.com/Ghost-0.5.9-zh-full.zip //下载Ghost到VPS  unzip Ghost-0.5.9-zh-full.zip -d ghost //解压Ghost-0.5.9-zh-full.zip并xiu修改文件夹名为ghost  </code></pre><p>如没有安装unzip，请执行 sudo yum install unzip 来安装，</p><p>&#160;&#160;到这里需要注意，ghost文件夹里的所有文件全部移动到之前你新建虚拟主机的web根目录下，不然会出错，文件移动号后，进入虚拟主机的web根目录下</p><pre><code>cd /虚拟主机web根目录路径   //进入虚拟主机web根目录，此步骤不能少  cp config.example.js config.js //复制config.example.js成config.js  vim config.js //用vim编辑config.js文件  </code></pre><p>将相关位置修改成以下这样：</p><pre><code>production: {  url: &apos;http://your_blog_url&apos;,mail: {},database: {client: &apos;mysql&apos;,connection: {host     : &apos;127.0.0.1&apos;, user     : &apos;root&apos;, //暂且直接用root账户password : &apos;password&apos;, //你的root账户密码database : &apos;ghost&apos;, //你之前建立的数据库名charset  : &apos;utf8&apos;},debug: false},server: {// Host to be passed to node&apos;s                 `net.Server#listen()`host: &apos;127.0.0.1&apos;,//改为0.0.0.0，否则他人无法访问// Port to be passed to node&apos;s `net.Server#listen()`, for iisnode set this to `process.env.PORT`port: &apos;2368&apos;}},</code></pre><p>这里说一下vim编辑器的一般用法：</p><p>i: 进入插入编辑模式</p><p>ESC: 退出编辑模式</p><p>:x : 退出并保存文件（退出编辑模式下使用）</p></li><li><p>配置Nginx</p><p>由于之前你新建的虚拟主机的Nginx配置是为php服务的，所以，我们要将其进行修改成为node.js服务，</p><pre><code>vim /usr/local/nginx/conf/***.conf //进入Nginx配置文件目录,并编辑与你新建的虚拟主机相应的Nginx配置文件  </code></pre><p>清空里面的内容，替换成以下：</p><pre><code>server {  listen 80;server_name  xxx.com www.xxxx.com; //替换为你自己的域名！location / {proxy_set_header   X-Real-IP $remote_addr;proxy_set_header   Host      $http_host;proxy_pass         http://127.0.0.1:2368; }}</code></pre><p>然后进AMH控制面板重启一下Nginx，</p><pre><code>npm start --production //启动Ghost，如果不出差错，在浏览器输入你的域名就可以看见Ghost的界面了，--production不能少  </code></pre><p>别以为到这就结束了，目前Ghost在我们SSH断开后就会结束进程，所以我们继续：</p></li><li><p>安装forever守护Ghost进程</p><p>为了让Ghost程序能够后台运行不中断，我们还得再安装个工具，就是forever，使用-g参数就是在全局模式中安装，这样我们就可以再任何地方都能使用forever命令了。</p><p>以下命令都请在网站根目录下运行</p><pre><code>npm install forever -g //forever的安装命令  NODE_ENV=production forever start index.js  //安装forever后的Ghost启动命令  </code></pre><p>   好了，Ghost就此安装完成</p></li></ol></li></ol><p>Ghost相关命令：</p><p>//以下命令都请在网站根目录下运行</p><pre><code>NODE_ENV=production forever start index.js //启动Ghost  NODE_ENV=production forever stop index.js //停止Ghost  NODE_ENV=production forever restart index.js //重启Ghost  </code></pre><p>现在，你就可以通过AMH控制面板进行数据管理、在线的文件编辑和上传 同样，你也可以按正常步骤新建一个php网站。</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ghost blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搭建hexo博客小记——hexo系列文章（一）</title>
      <link href="/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/"/>
      <url>/2016/05/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要介绍在Github下搭建Hexo博客。总体说来，搭建Hexo总共需要两步：</p><ul><li>第一部分，部署本地博客，也就是在你的电脑上搭建起来Web环境；</li><li>第二部分，生成静态页面，并上传到Github上去。<a id="more"></a></li></ul><h2 id="搭建本地博客系统"><a href="#搭建本地博客系统" class="headerlink" title="搭建本地博客系统"></a>搭建本地博客系统</h2><p>搭建本地博客系统首先要部署环境，即Node.js和Git。</p><h3 id="Node-js的安装"><a href="#Node-js的安装" class="headerlink" title="Node.js的安装"></a>Node.js的安装</h3><p>可以<a href="https://nodejs.org/" target="_blank" rel="noopener">点此</a>下载nodejs，并按照步骤一步步安装；一切默认即可；</p><h3 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h3><p>git bash，<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">点此</a>下载即可。<br>部署好本地环境，便可以开始安装博客系统Hexo了</p><h3 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h3><p>Hexo可直接用<code>npm</code>安装，可在电脑任意文件夹下右键Git Bash Here，进去后，在命令行中输入</p><pre><code>npm install -g hexo</code></pre><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><pre><code>npm install</code></pre><h3 id="发布本地博客"><a href="#发布本地博客" class="headerlink" title="发布本地博客"></a>发布本地博客</h3><p>到上一步为止，本地博客已搭建完成，下面我们可以发布本地博客看看效果：（即生成静态页面）</p><pre><code>hexo generatehexo server</code></pre><p>当然，也可以用简写：</p><pre><code>hexo ghexo s</code></pre><p>本地服务器开启后，我们就可以进入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>浏览本地博客了。</p><h2 id="上传本地文件到Github"><a href="#上传本地文件到Github" class="headerlink" title="上传本地文件到Github"></a>上传本地文件到Github</h2><h3 id="申请账号并建立仓库。"><a href="#申请账号并建立仓库。" class="headerlink" title="申请账号并建立仓库。"></a>申请账号并建立仓库。</h3><p>账号自行申请，建立仓库即在页面右上角的+除新建一个<code>repository</code>。但是命名有要求，必须用你的用户名加上github.io来命名仓库名。比如你的用户名为user123，那么就命名为user123.github.io。</p><h3 id="获取SSH公钥，并与Github账号绑定。"><a href="#获取SSH公钥，并与Github账号绑定。" class="headerlink" title="获取SSH公钥，并与Github账号绑定。"></a>获取SSH公钥，并与Github账号绑定。</h3><h4 id="设置邮箱和用户名"><a href="#设置邮箱和用户名" class="headerlink" title="设置邮箱和用户名"></a>设置邮箱和用户名</h4><pre><code>git config --global user.email &quot;user123@gmail.com&quot; </code></pre><p>git config –global user.name “user123”</p><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><pre><code>ssh-keygen -t rsa -C &quot;user@gmail.com&quot;</code></pre><p>命令运行后，会在<code>C:\Users\你的计算机名\.ssh</code>中找到<code>id_rsa.pub</code>这个文件，貌似是pubication的文件，但是我用office打不开，所以不管它了，如果有老兄知道这个究竟是用什么打开比较好，可以在评论区告诉我。不过它也是可以用txt打开的，将其中的内容复制到以下位置：</p><p>先登录github，点击右上角你的账户头像，进入settings，进入SSH key选项卡，将<code>id_rsa.pub</code>中的所有内容添加进去即可。</p><h4 id="更改博客配置，为上传做准备。"><a href="#更改博客配置，为上传做准备。" class="headerlink" title="更改博客配置，为上传做准备。"></a>更改博客配置，为上传做准备。</h4><p>打开<code>D:\hexo</code>目录下的配置文件<code>_config.yml</code>（推荐用软件Sublime Text打开，不要用txt打开，因为这要UTF-8编码，而txt不会编码），翻到最下面，并改成以下内容，把<code>user123g</code>替换成你的用户名即可</p><pre><code>deploy:type: gitrepository: https://github.com/user123/user123.github.io.gitbranch: master</code></pre><p>注意：<code>type</code>后面一定要是<code>git</code>，不要填<code>Github</code>。这是最新版hexo的要求。还有就是上面配置文件的语法较为严格<code>type:</code>后面一定要留一个空格，<code>repository</code>，<code>branch</code>也一样。</p><h2 id="上传博客内容"><a href="#上传博客内容" class="headerlink" title="上传博客内容"></a>上传博客内容</h2><h3 id="先生成静态文件"><a href="#先生成静态文件" class="headerlink" title="先生成静态文件"></a>先生成静态文件</h3><pre><code>hexo g</code></pre><h3 id="部署前先输入以下命令，不然会出现error-deployer-not-found-github的报错。"><a href="#部署前先输入以下命令，不然会出现error-deployer-not-found-github的报错。" class="headerlink" title="部署前先输入以下命令，不然会出现error deployer not found:github的报错。"></a>部署前先输入以下命令，不然会出现<code>error deployer not found:github</code>的报错。</h3><pre><code>npm install hexo-deployer-git --save</code></pre><h3 id="上传文档（部署）"><a href="#上传文档（部署）" class="headerlink" title="上传文档（部署）"></a>上传文档（部署）</h3><pre><code>hexo d</code></pre><p>待出现<code>INFO Deploy done: git</code>即成功。成功后，进入网址<code>http://user123..github.io</code>浏览查看。</p><p>至此，所有工作都已完成，如果想更改主题什么的，可以看我后续的博客。有问题欢迎大家留言。</p>]]></content>
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPS+Hexo+Dropbox创建个人博客——hexo系列教程（三）</title>
      <link href="/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/05/01/VPS+Hexo+Dropbox%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<blockquote><p>本文参考以下文章完成：<br>1.<a href="http://www.fanicy.com/2014/06/01/0001.hexowithvpsdropbox/" target="_blank" rel="noopener">用Hexo+Vps搭建博客并用Dropbox同步自动发布</a><br>2.<a href="http://www.jianshu.com/p/0839b09dc381#" target="_blank" rel="noopener">VPS+Dropbox+markeditor打造Hexo完美体验 (长期更新)</a><br>3.<a href="http://www.xmt.design/2016/04/04/blog-depoly-via-dropbox.html" target="_blank" rel="noopener">使用 Dropbox 和 VPS 实现实时部署 Hexo 博客</a></p></blockquote><p>废话少说，直接进入正题：</p><h2 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h2><p>为CentOS 6.8 x64 ,512MB内存</p><h2 id="安装需要的所有软件"><a href="#安装需要的所有软件" class="headerlink" title="安装需要的所有软件"></a>安装需要的所有软件</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git-core</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% 前三步是先安装EPEL</span><br><span class="line"># wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm </span><br><span class="line"># wget http://rpms.famillecollet.com/enterprise/remi-release-6.rpm</span><br><span class="line"># rpm -Uvh remi-release-6*.rpm epel-release-6*.rpm</span><br><span class="line">% 安装node</span><br><span class="line">yum install nodejs npm --enablerepo=epel</span><br></pre></td></tr></table></figure><h3 id="安装Dropbox"><a href="#安装Dropbox" class="headerlink" title="安装Dropbox"></a>安装Dropbox</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd ~ &amp;&amp; wget -O - &quot;https://www.dropbox.com/download?plat=lnx.x86_64&quot; | tar xzf -</span><br><span class="line">%然后，从新建的 .dropbox-dist 文件夹运行 Dropbox 守护程序.</span><br><span class="line">~/.dropbox-dist/dropboxd</span><br><span class="line">%下载官方提供的 cli 来控制和管理Dropbox</span><br><span class="line">wget https://linux.dropbox.com/packages/dropbox.py</span><br><span class="line">%更改权限:</span><br><span class="line">chmod +x ./dropbox.py</span><br><span class="line">%启动Dropbox:</span><br><span class="line">./dropbox.py start y</span><br><span class="line">关闭局域网广播:</span><br><span class="line">./dropbox.py lansync n</span><br></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">cd Dropbox</span><br><span class="line">mkdir hexo</span><br><span class="line">cd hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>这里推荐不是很熟悉Nginx设置的用以下链接提供的一键安装包安装，可以只安装Nginx，自动设置<br><a href="https://blog.linuxeye.com/31.html" target="_blank" rel="noopener">lnmp、lamp、lnmpa一键安装包</a><br>这里设置时，可以将主机目录设置为dropbox的同步目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/root/Dropbox/hexo/public</span><br></pre></td></tr></table></figure></p><p>添加权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 /root/Dropbox/hexo/public</span><br><span class="line">chown www:www /root/Dropbox/hexo/public</span><br><span class="line">chmod +x /root/Dropbox/ /root/Dropbox/hexo/</span><br></pre></td></tr></table></figure></p><h3 id="安装incron"><a href="#安装incron" class="headerlink" title="安装incron"></a>安装incron</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install incron</span><br><span class="line">service incrond start</span><br></pre></td></tr></table></figure><h2 id="同步发布"><a href="#同步发布" class="headerlink" title="同步发布"></a>同步发布</h2><p>incron 监测文件夹配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrontab -e</span><br></pre></td></tr></table></figure></p><p>在其中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/root/Dropbox/hexo/source/_posts/ IN_MOVE,IN_MODIFY,IN_CREATE,IN_DELETE /root/runhexo.bash</span><br><span class="line">/root/Dropbox/hexo/theme/ IN_MOVE,IN_MODIFY,IN_CREATE,IN_DELETE /root/runhexo.bash</span><br></pre></td></tr></table></figure></p><p>runhexo.bash:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env bash</span><br><span class="line">exec 200&lt;$0</span><br><span class="line">flock -n 200 || exit 1</span><br><span class="line">sleep 10</span><br><span class="line">cd /root/Dropbox/hexo &amp;&amp; hexo g</span><br></pre></td></tr></table></figure></p><p>添加权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x runhexo.bash</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> VPS </tag>
            
            <tag> Dropbox </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用KeePass2.x进行ftp或webdev同步</title>
      <link href="/2016/05/01/%E5%88%A9%E7%94%A8Keepass2.x%E8%BF%9B%E8%A1%8Cftp%E6%88%96webdev%E5%90%8C%E6%AD%A5/"/>
      <url>/2016/05/01/%E5%88%A9%E7%94%A8Keepass2.x%E8%BF%9B%E8%A1%8Cftp%E6%88%96webdev%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<blockquote><p>方法参考<a href="http://www.cnblogs.com/gumuyueying/p/keepass2-sync-trigger.html" target="_blank" rel="noopener">http://www.cnblogs.com/gumuyueying/p/keepass2-sync-trigger.html</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇博文介绍了利用软件Keepass保存密码。其实借助Dropbox或者其他同步软件将数据库.kpbx文件进行备份也很简单。但是由于某些原因，Dropbox很难上去。所以突然想到能否将文件保存在我的vps服务器上。在网上搜索教程就找到了这个方法。</p><a id="more"></a><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>其实同步很简单，只要借助KeePass自带的URL同步功能即可。如下图：</p><p><img src="http://i.imgur.com/XkgdsxV.png" alt=""></p><p>也就是选择“与URL同步”，<strong>但是要注意，必须现在指定位置建立一个.kpdb数据库文件</strong>，同步地址就填写该文件地址。</p><h2 id="自动同步"><a href="#自动同步" class="headerlink" title="自动同步"></a>自动同步</h2><p>手动同步很麻烦，那么怎么设置自动同步呢？这里可以借助KeePass自带的触发器功能，有点像Windows的“计划任务”，以下方法可以实现本地保存后，立马服务器同步的功能。</p><ol><li><p>“属性”选项卡，命名该触发器，如 SavedSync.（注意，后面动作选择“更改触发器 开/关 状态”时触发器名称只能手动输入，无法选择，所以这里命名还是从简，具体描述可以写到下面的注释栏。）同时勾选“启用”和“启动时打开”复选框。 </p></li><li><p>“事件”选项卡，添加事件，选择“已保存数据库文件”，下面的文件/URL - 比较和过滤器可以无视。不过如果有多个数据库文件需要同步，则可以根据待保存的数据库文件名设定后续同步动作。这里我的设置如下：<br><img src="http://i.imgur.com/4zcHdI0.png" alt=""></p></li><li><p>“条件”选项卡不加入任何条件。你也可以选择同步到 URL 文件时选择条件“远程主机可以连接(ping)”，这样只有当 URL 文件可以访问时才同步。不过我倾向于不加入这个条件，这样即使后面无法完成同步操作，也会有弹窗提示，让我们能更清楚当前的同步状态。</p></li></ol><p>我这里只做了简写，如果遇到某些问题，或者想更加详细地了解“触发器”功能，请访问原博客地址：<a href="http://www.cnblogs.com/gumuyueying/p/keepass2-sync-trigger.html" target="_blank" rel="noopener">http://www.cnblogs.com/gumuyueying/p/keepass2-sync-trigger.html</a></p><p>在此，对原作者表示感谢！</p>]]></content>
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KeePass </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KeePass+KeePassHTTP+chromeIPass储存个人密码</title>
      <link href="/2016/05/01/KeePass/"/>
      <url>/2016/05/01/KeePass/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在密码越来越多，但是为了密码安全还是不愿所有网站用同一个密码。所以就想到了用密码管理软件。尝试过1Password和Lastpass，可惜都收费。所以找到了KeePass，不仅免费，还开源。支持多平台。结合插件，可以实现在chrome上自动填写密码。<br><a id="more"></a></p><blockquote><p>本文参考<a href="http://devzc.com/post/465" target="_blank" rel="noopener">http://devzc.com/post/465</a>写作而成，再次对原作者表示感谢。</p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li><p>首先从以下网址下载所需文件</p><ul><li><p>KeePass主体程序:<br><a href="http://keepass.info/download.html" target="_blank" rel="noopener">http://keepass.info/download.html</a></p></li><li><p>KeePassHTTP扩展下载:<br><a href="https://github.com/pfn/keepasshttp/blob/master/KeePassHttp.plgx?raw=true" target="_blank" rel="noopener">https://github.com/pfn/keepasshttp/blob/master/KeePassHttp.plgx?raw=true</a><br>源码: <a href="https://github.com/pfn/keepasshttp/" target="_blank" rel="noopener">https://github.com/pfn/keepasshttp/</a></p></li><li><p>chromeIPass:<br>Chrome应用商店搜索[chromeIPass],安装即可;<br>chromeIPass源码: <a href="https://github.com/pfn/passifox" target="_blank" rel="noopener">https://github.com/pfn/passifox</a></p></li></ul></li><li><p>依次安装以上文件。<br>注意KeePassHTTP的配置：</p><ol><li>将KeePassHttp.plgx放在KeePass.exe同目录下,重启KeePass。并单击工具下的“KeePassHttp Options”。</li><li>按照如下图配置：<br><img src="http://i.imgur.com/0R82YzX.png" alt=""></li><li>点击Chrome上的chromeIPass图标，会出现Connect按钮,点击进去；</li><li>Key_Name自己起名</li><li><p>保存后，重新点击chromeIPass，若出现以下信息，则说明成功：</p><p><img src="http://i.imgur.com/PDcuXmf.png" alt=""></p></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KeePass </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>coding和github同时使用</title>
      <link href="/2016/05/01/coding%E5%92%8Cgithub%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/05/01/coding%E5%92%8Cgithub%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先贴几个我的参考网站：</p><blockquote><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">非常好的git学习站（入门）</a><br><a href="http://www.tuicool.com/articles/NZNJVvB" target="_blank" rel="noopener">Git管理多个远程仓库(以Github和Coding为例)</a><br><a href="http://my.oschina.net/450192529/blog/636106" target="_blank" rel="noopener">如何在同一台电脑上使用两个github,一个往coding推，一个往github推，亲测有效哦</a><br><a href="http://blog.csdn.net/chaoyue0071/article/details/41824339" target="_blank" rel="noopener">如何在同一台电脑上使用两个github账户</a><br><a href="http://www.cnblogs.com/sheldonxu/archive/2012/09/17/2688281.html" target="_blank" rel="noopener">执行ssh-add时出现Could not open a connection to your authentication agent</a><br><a href="http://blog.163.com/023_dns/blog/static/1187273662013111301046930/" target="_blank" rel="noopener">github常见操作和常见错误！错误提示：fatal: remote origin already exists. </a></p></blockquote>]]></content>
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
            <tag> Github </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
